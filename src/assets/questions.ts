import { Question } from 'src/app/models/question.model';

export const questions: Question[] = [
  {
    id: 1,
    name: 'Как браузер парсит страницу?',
    answer: `
      <p>Процесс отображения страниц браузером можно разбить на следующие основные этапы:</p>

      <ol>
        <li>Парсинг HTML, построение DOM</li>
        <li>Получение внешних ресурсов</li>
        <li>Разбор CSS и создание CSSOM</li>
        <li>Выполнение JavaScript</li>
        <li>Объединение DOM и CSSOM, для построения дерево рендеринга</li>
        <li>Расчет макета и отрисовка результата</li>
      </ol>

      <h3>
        1. Парсинг HTML, построение DOM
      </h3>

      <p>
        Когда браузер начинает получать данные HTML страницы по сети, он немедленно запускает
        свой синтаксический анализатор parser для преобразования HTML в объектную модель документа (DOM).
      </p>

      <p class="info info--blue">
        Объектная модель документа (DOM) — это представление данных объектов,
        которые составляют структуру и содержимое документа в Интернете.
      </p>

      <p>
        Первый шаг этого процесса синтаксического анализа — разбить HTML на токены, которые представляют начальные
        теги (start tags), конечные теги (end tags) и их содержимое (contents). Из этого он строит DOM.
      </p>

      <img src="../assets/img/step-1.png">

      <h3>
        2. Получение внешних ресурсов
      </h3>

      <p>
        Когда парсер встречает внешний ресурс, такой как файл CSS или JavaScript, он пытается получить его.
        Синтаксический анализатор будет продолжать работу по мере загрузки файла CSS, но он заблокирует
        рендеринг до тех пор, пока файл не будет загружен и проанализирован (подробнее об этом чуть позже).
      </p>

      <p>
        Файлы JavaScript немного отличаются — по умолчанию они так же блокируют синтаксический анализ HTML
        на время загрузки. Но у них есть два атрибута, которые могут быть добавлены в теги сценария, чтобы
        изменить это: <code>defer</code> и <code>async</code>. Оба позволяют синтаксическому анализатору продолжать работу, пока файл
        JavaScript загружается в фоновом режиме. Они отличаются друг от друга тем, как выполняются.
        Подробнее об этом тоже немного ниже, но вкратце:
      </p>

      <p>
        <code>defer</code> означает, что выполнение файла будет отложено до завершения синтаксического анализа документа.
        Если несколько файлов имеют атрибут <code>defer</code>, то они будут выполняться в том порядке, в котором они
        были обнаружены в HTML.
      </p>

      <code class="code">
        &lt;script type="text/javascript" src="script.js" defer>
      </code>

      <p>
        <code>async</code> означает, что файл будет выполнен, как только он загрузится, это может быть во время или после процесса
        синтаксического анализа, и поэтому порядок, в котором выполняются асинхронные сценарии, не может быть гарантирован.
      </p>

      <code class="code">
        &lt;script type="text/javascript" src="script.js" async>
      </code>

      <h3>
        Предварительная загрузка ресурсов
      </h3>

      <p>
        Кроме того, современные браузеры будут продолжать сканировать HTML-код, пока анализатор блокирован, и «смотреть вперед»
        на то, какие внешние ресурсы появляются, а затем загружать их предположительно. То, как они это делают, варьируется в
        зависимости от браузера, поэтому нельзя полагаться на то, что они будут вести себя определенным образом. Чтобы пометить
        ресурс как важный и, следовательно, с большей вероятностью он должен быть загруженным на ранней стадии процесса рендеринга,
        можно использовать тег ссылки с <code>rel = «preload»</code>.
      </p>

      <code class="code">
        &lt;link href="style.css" rel="preload" as="style" />
      </code>

      <img src="../assets/img/step-2.png">

      <h3>
        3. Разбор CSS и создание CSSOM
      </h3>

      <p>
        Возможно, вы слышали о DOM, но слышали ли вы о CSSOM (CSS Object Model) (объектной модели CSS)?
        До того, как я начал исследовать эту тему, я об этом ни чего не знал!
      </p>

      <p class="info info--blue">
        Объектная модель CSS (CSSOM) — это карта всех селекторов CSS и соответствующих свойств для каждого селектора
        в форме дерева с корневым узлом, родственником, потомком, дочерним элементом и другими отношениями.
        CSSOM очень похож на объектную модель документа (DOM). Оба они являются частью пути рендеринга,
        который представляет собой серию шагов, которые должны пройти для правильного рендеринга веб-сайта.
      </p>

      <p class="info info--blue">
        CSSOM вместе с DOM используется для построения дерева рендеринга,
        которое, в свою очередь, используется браузером для компоновки и раскраски веб-страницы.
      </p>

      <p>
        Подобно файлам HTML и DOM, когда файлы CSS загружаются, они должны быть проанализированы и
        преобразованы в дерево — на этот раз CSSOM. Он описывает все селекторы CSS на странице, их иерархию и их свойства.
      </p>

      <p>
        Чем CSSOM отличается от DOM, так это тем, что он не может быть построен постепенно, поскольку правила CSS могут
        перезаписывать друг друга в разных точках из-за specificity (порядка применения свойства).
        Вот почему загрузка CSS блокирует рендеринг, поскольку до тех пор, пока весь CSS не будет
        проанализирован и не будет построен CSSOM, браузер не может знать, где и как разместить каждый элемент на экране.
      </p>

      <img src="../assets/img/step-3.jpeg">

      <h3>
        4. Выполнение JavaScript
      </h3>

      <p>
        Как и когда ресурсы JavaScript будут загружены определяет то, в какой момент они будут проанализированы, скомпилированы
        и выполнены. В разных браузерах для выполнения этой задачи используются разные механизмы JavaScript.
        Анализ JavaScript может быть дорогостоящим процессом с точки зрения ресурсов компьютера,
        в большей степени, чем другие типы ресурсов, поэтому его оптимизация так важна для достижения хорошей производительности.
      </p>

      <h3>
        События загрузки
      </h3>

      <p>
        После того, как синхронно загруженный JavaScript и DOM будут полностью проанализированы и готовы, будет сгенерировано
        событие document.DOMContentLoaded. Для любых сценариев, которым требуется доступ к DOM, например, для
        управления им или прослушивания событий взаимодействия с пользователем, рекомендуется сначала дождаться этого
        события перед выполнением сценариев.
      </p>

      <code class="code">
        document.addEventListener('DOMContentLoaded', (event) => {
          // You can now safely access the DOM
        });
      </code>

      <p>
        После того, как все остальное, например асинхронный JavaScript, изображения и т. д.,
        завершили загрузку, запускается событие window.load.
      </p>

      <code class="code">
        window.addEventListener('load', (event) => {
          // The page has now fully loaded
        });
      </code>

      <br>

      <img src="../assets/img/step-4.png">

      <h3>
        5. Объединение DOM и CSSOM, построение дерева рендеринга
      </h3>

      <p>
        Дерево рендеринга представляет собой комбинацию DOM и CSSOM и представляет всё, что будет отображаться на странице.
        Это не обязательно означает, что все узлы в дереве рендеринга будут визуально присутствовать.
        <br>
        Например, узлы со стилями <code>opacity: 0</code> или <code>visibility: hidden</code> будут включены и
        могут быть прочитаны программой чтения с экрана и т. д. Тогда как те, которые имеют стиль <code>display: none</code>,
        будут исключены. Кроме того, теги вроде &lt;head>, не содержащие визуальной информации, всегда будут пропущены.
      </p>

      <p>
        Как и в случае с движками JavaScript, разные браузеры имеют разные механизмы рендеринга.
      </p>

      <img src="../assets/img/step-5.png">

      <h3>
        6. Расчет макета и отрисовка результата
      </h3>

      <p>
        Теперь, когда у нас есть полное дерево рендеринга, браузер знает, что рендерить, но не знает, где рендерить.
        Следовательно, необходимо рассчитать макет страницы (то есть положение и размер каждого узла).
        Механизм рендеринга проходит дерево рендеринга, начиная с вершины и идя вниз, вычисляет координаты, в
        которых должен отображаться каждый узел.
      </p>

      <p>
        Как только это будет сделано, последний шаг — используя эту информацию о макете, отрисовать пиксели на экране.
      </p>

      <p>
        И вуаля! В конце концов, у нас есть полностью отрисованная веб-страница!
      </p>

      <img src="../assets/img/step-6.png">

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://webdevblog.ru/kak-brauzer-renderit-veb-stranicu/">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['markup', 'browser'],
    structure: [
      {
        name: 'Парсинг HTML, построение DOM',
        isChecked: false,
      },
      {
        name: 'Получение внешних ресурсов (JS, CSS)',
        isChecked: false,
      },
      {
        name: 'Разбор CSS и создание CSSOM',
        isChecked: false,
      },
      {
        name: 'Выполнение JavaScript',
        isChecked: false,
      },
      {
        name: 'Объединение DOM и CSSOM для построения дерево рендеринга',
        isChecked: false,
      },
      {
        name: 'Расчет макета и отрисовка результата',
        isChecked: false,
      },
    ],
  },
  {
    id: 2,
    name: 'Что такое <DOCTYPE>. Зачем он нужен?',
    answer: `
      <h3>
        Что такое DOCTYPE?
      </h3>
      <p>
        <span class="accent">Тег &lt;!doctype></span>
        — DTD (document type definition, описание типа документа) указывает тип документа,
        который используется при написании html кода. Это непарный тег, который должен стоять самым первым в
        коде каждой страницы вашего сайта.
      </p>

      <p>
        Нужно понимать, что строчка, в которой прописывается <code>DOCTYPE</code> - это не просто очередной HTML тег.
        Это важная инструкция, с помощью которой мы говорим браузеру, какая версия HTML использовалась при написании страницы.
      </p>

      <p>
        Главным преимуществом использования <code>DOCTYPE</code> является то,
        что ваш сайт будет правильно работать и одинаково ровно и красиво смотреться во всех браузерах.
      </p>

      <h3>
        Зачем нужен DOCTYPE?
      </h3>

      <p>
        Тег <code>DOCTYPE</code> — ключевой компонент web-страниц, претендующих на соответствие стандартам:
        без него ваш код и CSS не пройдут проверку валидатором.
        Тег <code>DOCTYPE</code> также важен для правильного отображения и работы страницы в броузерах, соответствующих стандартам
        (Mozilla, IE5/Mac, и IE6/Win).
      </p>

      <h3>
        Какие существуют виды DOCTYPE?
      </h3>

      <p>
        Cуществует несколько видов <code>DOCTYPE</code>. Есть строгие виды (<strong>strict</strong>),
        которые работают на основе только определенных тегов, есть переходные (<strong>transitional</strong>),
        которые допускают возможность включения дополнительных тегов, есть такие, которые работают с фреймами
        (<strong>frameset</strong>).
      </p>

      <p>Подробно в этой статье я не буду рассматривать каждый из них, так как это не является моей целью, просто перечислю:</p>

      <ol>
        <li><strong>HTML 5</strong></li>
        <li><strong>HTML 4.01 Strict</strong></li>
        <li><strong>HTML 4.01 Transitional</strong></li>
        <li><strong>HTML 4.01 Frameset</strong></li>
        <li><strong>XHTML 1.0 Strict</strong></li>
        <li><strong>XHTML 1.0 Transitional</strong></li>
        <li><strong>XHTML 1.0 Frameset</strong></li>
        <li><strong>XHTML 1.1</strong></li>
      </ol>

      <p>
        Что касается использования разных видов <code>DOCTYPE</code>, следует иметь ввиду, что если вы изначально писали свой
        сайт в одном <code>DOCTYPE</code>, то не рекомендуется его менять в будущем на какой-то другой, потому что могут
        возникнуть проблемы с правильным отображением сайта из-за того, что вместе со сменой <code>DOCTYPE</code> вы
        автоматически поменяете правила обработки тегов браузерами.
      </p>

      <h3>
        Можно ли вообще обойтись без DOCTYPE?
      </h3>

      <p>
        Теоретически, <code>DOCTYPE</code> не является необходимым тегом, но если вы не используете <code>DOCTYPE</code>
        совсем, то рискуете лицезреть созданный вами сайт не в самом приглядном виде в браузере.
        Причем в каждом браузере будут возникать разные проблемы с правильностью отображения,
        а решить все их вам будет, мягко говоря, сложновато.
      </p>

      <h3>
        Преимущества использования DOCTYPE HTML5
      </h3>

      <p>
        Хорошая новость состоит в том, что с выходом последней версии HTML5 стало намного удобней выбирать DOCTYPE для своих сайтов.
      </p>

      <p>
        Дело в том, что правила <code>DOCTYPE</code> HTML5 являются универсальными, включают в себя правила предыдущей версии,
        а также возможность работы с HTML 4 тегами и, в какой-то степени, с XHTML.
        Насколько я понимаю, они объединяют в себе возможности всех своих предшественников, адаптируя их для работы в новых браузерах.
      </p>

      <p>
        Поэтому сейчас следует (практически) всегда использовать <code>DOCTYPE</code> HTML5,
        для чего просто следует добавить в начале страницы:
      </p>

      <code class="code">
        &lt;!DOCTYPE html>
      </code>

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://mega-css.com/page/doctype">Источник 1</a>
        </li>
        <li>
          <a href="https://habr.com/ru/post/71364/">Источник 2</a>
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup'],
    structure: [
      {
        name: 'Что такое этот тег DOCTYPE',
        isChecked: false,
      },
      {
        name: 'Зачем нужен DOCTYPE',
        isChecked: false,
      },
      {
        name: 'Рассказать, про то что есть разные виды DOCTYPE',
        isChecked: false,
      },
      {
        name: 'Можно ли вообще обойтись без DOCTYPE?',
        isChecked: false,
      },
      {
        name: 'Сейчас практически всегда стоит юзать DOCTYPE HTML5',
        isChecked: false,
      }
    ],
  },
  {
    id: 3,
    name: 'Теги HTML5. Семантика. Доступность.',
    answer: `
      <h3>
        Что такое семантическая вёрстка и зачем она нужна
      </h3>

      <p class="info info--blue">
        Давным-давно (лет 10-15 назад) почти все делали сайты и не переживали о том, что под капотом.
        Верстали таблицами, использовали всё, что попадётся под руку (а попадались в основном div и span) и
        не особо заморачивались о доступности.
        <br>
        <br>
        А потом случился HTML5 - и понеслось.
      </p>

      <p>
        <span class="accent">Семантическая вёрстка</span> — подход к разметке, который опирается не на содержание сайта,
        а на смысловое предназначение каждого блока и логическую структуру документа.
        Даже в этой статье есть заголовки разных уровней — это помогает читателю выстроить в голове структуру документа.
        Так и на странице сайта — только читатели будут немного другими.
      </p>

      <h3>
        Почему семантика важна
      </h3>

      <p>
        <strong>Чтобы сделать сайт доступным.</strong> Зрячие пользователи могут без проблем с первого взгляда понять,
        где какая часть страницы находится — где заголовок, списки или изображения. Для незрячих или частично незрячих
        всё сложнее. Основной инструмент для просмотра сайтов не браузер, который отрисовывает страницу, а скринридер,
        который читает текст со страницы вслух.
        <br>
        Этот инструмент «зачитывает» содержимое страницы, и семантическая структура помогает ему лучше определять,
        какой сейчас блок, а пользователю понимать, о чём идёт речь.
      </p>

      <p>
        <strong>Чтобы сайт был выше в поисковиках.</strong> Компании, которые создают поисковики, не разглашают правила ранжирования,
        но известно, что наличие семантической разметки страниц помогает поисковым ботам лучше понимать, что находится
        на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.
      </p>

      <p>
        Семантика прописана в стандартах. Многие разработчики по старинке пользуются конструкциями типа <code>&lt;div id="nav"></code>
        для обозначения навигации или других структурных элементов страницы. Тем временем в стандарте HTML есть несколько
        семантических тегов, которые рекомендуется использовать для разметки страниц вместо <code>&lt;div></code> и <code>&lt;span></code>.
        В спецификации для каждого семантического элемента описана его роль.
      </p>

      <p>
        Ну и представьте, насколько проще читать <code>&lt;nav>&lt;/nav></code> вместо <code>&lt;div class="nav">&lt;/div></code>.
        <br>
        Или вот такой код. Смотрите и сразу понятно, что тут и зачем:
      </p>

      <code class="code">
        &lt;!DOCTYPE html>
        &lt;html lang="ru">
          &lt;head>
            &lt;meta charset="utf-8">
            &lt;title>Заголовок страницы&lt;/title>
          &lt;/head>
          &lt;body>
            &lt;header class="main-header">
              &lt;!— Шапка сайта —>
            &lt;/header>
            &lt;main>
              &lt;!— Основное содержимое страницы —>
            &lt;/main>
            &lt;footer class="main-footer">
              &lt;!— Подвал сайта —>
            &lt;/footer>
          &lt;/body>
        &lt;/html>
      </code>

      <h3>
        Основные семантические теги HTML
      </h3>

      <p>
        Среди «старых» тегов из ранних версий HTML тоже есть семантические — например, тег <code>&lt;p></code>,
        который обозначает параграф. При этом теги <code>&lt;i></code> или <code>&lt;b></code> не семантические, потому что они
        не добавляют смысла выделенному тексту, а просто определяют его внешний вид.
      </p>

      <p>
        Но в актуальной версии стандарта HTML Living Standard есть семантические
        теги почти для всех основных частей сайта, и лучше пользоваться ими. Вот несколько примеров семантических тегов.
      </p>

      <h4>
        &lt;article>
      </h4>

      <p>
        <strong>Значение:</strong> независимая, отделяемая смысловая единица, например комментарий, твит, статья, виджет ВК и так далее.
      </p>

      <p>
        <strong>Особенности:</strong> желателен заголовок внутри.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> путают с тегами <code>&lt;section></code> и <code>&lt;div></code>.
      </p>

      <h4>
        &lt;section>
      </h4>

      <p>
        <strong>Значение:</strong> смысловой раздел документа. Неотделяемый, в отличие от <code>&lt;article></code>.
      </p>

      <p>
        <strong>Особенности:</strong> желателен заголовок внутри.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> путают с тегами <code>&lt;article></code> и <code>&lt;div></code>.
      </p>

      <h4>
        &lt;aside>
      </h4>

      <p>
        <strong>Значение:</strong> побочный, косвенный для страницы контент.
      </p>

      <p>
        <strong>Особенности:</strong> может иметь свой заголовок. Может встречаться несколько раз на странице.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> считать <code>&lt;aside></code> тегом для «боковой панели» и
        размечать этим тегом основной контент, который связан с окружающими его элементами.
      </p>

      <h4>
        &lt;nav>
      </h4>

      <p>
        <strong>Значение:</strong> навигационный раздел со ссылками на другие страницы или другие части страниц.
      </p>

      <p>
        <strong>Особенности:</strong> используется для основной навигации, а не для всех групп ссылок.
        Основной является навигация или нет — на усмотрение верстальщика.
        Например, меню в подвале сайта можно не оборачивать в <code>&lt;nav></code>. В подвале обычно появляется краткий
        список ссылок (например, ссылка на главную, копирайт и условия) — это не является основной навигацией,
        семантически для такой информации предназначен <code>&lt;footer></code> сам по себе.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> многие считают, что в <code>&lt;nav></code> может быть
        только список навигационных ссылок, но согласно спецификации там может быть навигация в любой форме.
      </p>

      <h4>
        &lt;header>
      </h4>

      <p>
        <strong>Значение:</strong> вводная часть смыслового раздела или всего сайта, обычно содержит
        подсказки и навигацию. Чаще всего повторяется на всех страницах сайта.
      </p>

      <p>
        <strong>Особенности:</strong> этих элементов может быть несколько на странице.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> использовать только как шапку сайта.
      </p>

      <h4>
        &lt;main>
      </h4>

      <p>
        <strong>Значение:</strong> основное, не повторяющееся на других страницах, содержание страницы.
      </p>

      <p>
        <strong>Особенности:</strong> должен быть один на странице, исходя из определения.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> включать в этот тег то, что повторяется на других страницах (навигацию, копирайты и так далее).
      </p>

      <h4>
        &lt;footer>
      </h4>

      <p>
        <strong>Значение:</strong> заключительная часть смыслового раздела или всего сайта, обычно содержит информацию об авторах,
        список литературы, копирайт и так далее. Чаще всего повторяется на всех страницах сайта.
      </p>

      <p>
        <strong>Особенности:</strong> этих элементов может быть несколько на странице. Тег <code>&lt;footer></code>
        не обязан находиться в конце раздела.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> использовать только как подвал сайта.
      </p>

      <h3>
        Как разметить страницу с точки зрения семантики
      </h3>

      <p>
        Процесс разметки можно разделить на несколько шагов с разной степенью детализации.
      </p>

      <ol>
        <li>
          Крупные смысловые блоки на каждой странице сайта. Теги: <code>&lt;header&gt;, &lt;main&gt;, &lt;footer&gt;</code>.
        </li>
        <li>
          Крупные смысловые разделы в блоках. Теги: <code>&lt;nav&gt;, &lt;section&gt;, &lt;article&gt;, &lt;aside&gt;</code>.
        </li>
        <li>Заголовок всего документа и заголовки смысловых разделов. Теги: <code>&lt;h1&gt;-&lt;h6&gt;</code>.</li>
        <li>
          Мелкие элементы в смысловых разделах. Списки, таблицы, демо-материалы, параграфы и переносы,
          формы, цитаты, контактная информация и прогресс.
        </li>
        <li>Фразовые элементы. Изображения, ссылки, кнопки, видео, время и мелкие текстовые элементы.</li>
      </ol>

      <p>
        Более подробно методика создания семантической разметки описана в навыке
        <a href="https://htmlacademy.ru/skills/semantic-markup">
          Создание семантической разметки по макету
        </a>.
      </p>

      <h3>
        Сомневаюсь, какие теги использовать
      </h3>

      <p>Есть простые правила для выбора нужных тегов.</p>

      <ul>
        <li>Получилось найти самый подходящий смысловой тег - использовать его.</li>
        <li>Для потоковых контейнеров - <code>&lt;div&gt;</code>.</li>
        <li>Для мелких фразовых элементов (слово или фраза) - <code>&lt;span&gt;</code>.</li>
      </ul>

      <p>Правило для определения <code>&lt;article&gt;, &lt;section&gt;</code> и <code>&lt;div&gt;</code>:</p>

      <ol>
        <li>Можете дать имя разделу и вынести этот раздел на другой сайт? - <code>&lt;article&gt;</code></li>
        <li>Можете дать имя разделу, но вынести на другой сайт не можете? - <code>&lt;section&gt;</code></li>
        <li>
          Не можете дать имя? Получается что-то наподобие "новости и фотогалерея" или "правая колонка"? - <code>&lt;div&gt;</code>
        </li>
      </ol>


      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://htmlacademy.ru/blog/boost/frontend/semantics">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup'],
    structure: [
      {
        name: 'Что такое семантическая вёрстка и зачем она нужна',
        isChecked: false,
      },
      {
        name: 'Основные семантические теги HTML',
        isChecked: false,
      },
      {
        name: 'Как разметить страницу с точки зрения семантики',
        isChecked: false,
      },
    ],
  },
  {
    id: 4,
    name: 'Какие есть способы подключить CSS на страницу?',
    answer: `
      <p>
        Каскадные таблицы стилей CSS (Cascading Style Sheets) нужны для оформления страниц вашего сайта в соответствии с
        разработанным стилем, дизайном.
      </p>

      <p>
        Таблицы стилей CSS являются неотъемлемой частью страниц современного сайта. Рассмотрим как подключить CSS к HTML документу.
      </p>

      <p>
        Существует 5 основных способов подключения или добавления CSS стилей к HTML документу, каждый их которых
        подходит для определенного круга задач.
      </p>

      <h3>
        1. Подключение CSS через внешний файл стилей тегом link
      </h3>

      <p>
        Наиболее правильный вариант определения общих стилей для сайта - это подключение внешнего файла CSS с помощью тега &lt;link>.
      </p>

      <p>
        Чтобы подключить CSS файл, в head области страницы используйте следующую конструкцию:
      </p>

      <code class="code">
        &lt;link href="URL_адрес_CSS_файла" rel="stylesheet" type="text/css">
      </code>

      <p>
        В атрибуте href необходимо указать URL адрес файла, содержащего набор стилей CSS.
        Атрибуты <code>rel="stylesheet"</code> и <code>type="text/css"</code> указывают,
        что указанный файл является таблицей стиля в формате CSS.
      </p>

      <p>
        Вы можете привязать неограниченное количество файлов CSS к одной странице сайта.
        Однако подключение большого количества объемных CSS файлов приведет к увеличению веса страницы, и
        соответственно может привести к увеличению времени загрузки и обработки страницы.
      </p>

      <h3>
        2. Добавление CSS с помощью тега style
      </h3>

      <p>
        Этот метод подойдет когда нужно вставить (определить) стили для группы уникальных элементов страницы,
        то есть, набор стилей, которые используются только в пределах одной страницы и не нужны для корректной
        работы остальных страниц сайта.
      </p>

      <p>
        В любом месте областей <code>&lt;head></code>и <code>&lt;body></code> HTML документа используйте тег <code>&lt;style></code>,
        внутри которого поместите необходимые CSS правила.
      </p>

      <code class="code">
        &lt;style type="text/css">
          /* CSS код */
        &lt;/style>
      </code>

      <h3>
        3. Импорт CSS через команду @import
      </h3>

      <p>
        В текущую стилевую таблицу можно импортировать содержимое CSS-файла с помощью команды <code>@import</code>.
        Этот метод допускается использовать совместно со связанными или глобальными стилями, но никак не с внутренними стилями.
        Общий синтаксис следующий.
      </p>

      <code class="code">
        @import url("имя файла") типы носителей;
        @import "имя файла" типы носителей;
      </code>

      <h3>
        4. Inline-стили CSS
      </h3>

      <p>
        Если вам нужно задать стиль для конкретного элемента контента страницы (одного конкретного тега),
        воспользуйтесь атрибутом <code>style</code>.
      </p>

      <code class="code">
        &lt;p style="CSS_код">текст&lt;/p>
      </code>

      <p>
        Стили, заданные через атрибут <code>style</code> называют inline-стилями.
        Такие стили имеют приоритет перед стилями, заданными через внешний файл или с помощью тега <code>&lt;style></code>,
        но есть исключения.
      </p>

      <h3>
        5. Стили CSS через JavaScript
      </h3>

      <p>
        Практически на каждом современном сайте используются скрипты, написанные на языке JavaScript.
      </p>

      <p>
        В JavaScript есть много различных функций для управления стилями HTML элементов.
        При использовании этих функций CSS свойства добавляются в style атрибут тега.
      </p>

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="http://htmlbook.ru/samcss/sposoby-dobavleniya-stiley-na-stranitsu">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Подключение CSS через внешний файл стилей тегом link',
        isChecked: false,
      },
      {
        name: 'Добавление CSS с помощью тега style',
        isChecked: false,
      },
      {
        name: 'Импорт CSS через команду @import',
        isChecked: false,
      },
      {
        name: 'Inline-стили CSS',
        isChecked: false,
      },
      {
        name: 'Стили CSS через JavaScript',
        isChecked: false,
      },
    ],
  },
  {
    id: 5,
    name: 'Приоритет стилей. Каскадность.',
    answer: `
      <h3>
        Приоритет стилей. Каскадность.
      </h3>

      <p>
        <span class="accent">Каскадность</span> в CSS определяет, как браузер разрешает конфликты стилей, когда к одному элементу применяется несколько правил. Приоритет стилей рассчитывается на основе специфичности селекторов, порядка их объявления и использования <code>!important</code>. Более специфичные селекторы имеют больший вес, а при равной специфичности применяется последнее объявленное правило.
      </p>

      <h3>
        Специфичность селекторов
      </h3>

      <p>
        Это вес, который присваивается CSS-правилу. Рассчитывается как (inline, ID, class/attr/pseudo-class, type/pseudo-element).
      </p>

      <h3>
        Порядок объявления
      </h3>

      <p>
        Если специфичность одинакова, применяется правило, которое было объявлено последним в коде.
      </p>

      <h3>
        !important
      </h3>

      <p>
        Правило с <code>!important</code> имеет наивысший приоритет и переопределяет любые другие стили, независимо от их специфичности.
      </p>

      <h3>
        Источник стилей
      </h3>

      <p>
        Стили браузера (user agent) имеют самый низкий приоритет, затем идут стили пользователя (user), и самый высокий приоритет у стилей автора (author).
      </p>
    `,
    tags: ['css'],
    structure: [
      {
        name: 'Специфичность селекторов',
        isChecked: false,
      },
      {
        name: 'Порядок объявления',
        isChecked: false,
      },
      {
        name: '!important',
        isChecked: false,
      },
      {
        name: 'Источник стилей',
        isChecked: false,
      }
    ],
  },
  {
    id: 6,
    name: '“Вес” селекторов CSS',
    answer: `
      <p>
        <span class="accent">Вес селектора (Specificity)</span> — это алгоритм, по которому браузер решает, какое из противоречащих правил CSS применить к элементу. Представь это как соревнование: кто «тяжелее», тот и победил.
        Если два селектора имеют одинаковый вес, побеждает тот, который написан ниже в коде.
      </p>

      <p>
        <h3>Как считать вес (Система 0-0-0-0)</h3>
        Представь вес как четырехзначное число (или четыре колонки). Чем старше разряд, тем важнее цифра.
      </p>

      <h3>0. !important</h3>
      <p>Это «чит-код». Это ключевое слово выводит правило из общей системы подсчета очков. Оно говорит браузеру: «Плевать на вес селектора, примени это свойство любой ценой!».</p>

      <p>Это условные 1-0-0-0-0 (десять тысяч).</p>

      <h3>1. Колонка тысяч (Inline-стили) — style=""</h3>
      <p>Самые тяжелые селекторы. Inline-стили перебивают любые другие селекторы.</p>

      <p>Вес: 1-0-0-0</p>

      <h3>2. Колонка сотен (ID) — #id</h3>
      <p>Самые тяжелые селекторы в обычном потоке. Один ID перебивает любое количество классов.</p>

      <p>Пример: #header</p>

      <p>Вес: 0-1-0-0</p>

      <h3>3. Колонка десятков (Классы, Атрибуты, Псевдоклассы) — .class, [type="text"], :hover</h3>
      <p>Самая рабочая группа.</p>

      <p>Пример: .btn, [required], :nth-child(2)</p>

      <p>Вес: 0-0-1-0</p>

      <h3>4. Колонка единиц (Теги, Псевдоэлементы) — div, ::before</h3>
      <p>Самые легкие.</p>

      <p>Пример: h1, span, ::after</p>

      <p>Вес: 0-0-0-1</p>

      <h3>5. Нулевой вес:</h3>
      <p>Универсальный селектор *, комбинаторы +, >, ~ и :not() не добавляют веса сами по себе (но то, что внутри :not, вес имеет).</p>
    `,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: '!important',
        isChecked: false,
      },
      {
        name: 'Inline-стили',
        isChecked: false,
      },
      {
        name: 'ID',
        isChecked: false,
      },
      {
        name: 'Классы, Атрибуты, Псевдоклассы',
        isChecked: false,
      },
      {
        name: 'Теги, Псевдоэлементы',
        isChecked: false,
      },
      {
        name: 'Нулевой вес',
        isChecked: false,
      },
    ],
  },
  {
    id: 7,
    name: 'Высокая специфичность селектора, есть ли у нее какие-то недостатки?',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 8,
    name: '!important',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 9,
    name: 'Селекторы: > + ~',
    answer: `
      <span class="accent">Соседний комбинатор (+)</span> — это селектор, который выбирает элемент, который непосредственно следует за этим элементом.
      <p>Например, <code>h1 + p</code> выберет первый <code>&lt;p></code>, который идет сразу после <code>&lt;h1></code>.</p>

      <span class="accent">Дочерний комбинатор (>)</span> — это селектор, который выбирает элементы, которые являются непосредственными детьми элемента.
      <p>Например, <code>ul > li</code> выберет все <code>&lt;li></code>, которые являются непосредственными детьми <code>&lt;ul></code></p>

      <span class="accent">Общий соседний комбинатор (~)</span> — это селектор, который выбирает все элементы, которые следуют за элементом на одном уровне вложенности.
      <p>Например, <code>h2 ~ p</code> выберет все <code>&lt;p></code>, которые идут после <code>&lt;h2></code>, но не обязательно сразу после него.</p>
    `,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: '>',
        isChecked: false,
      },
      {
        name: '+',
        isChecked: false,
      },
      {
        name: '~',
        isChecked: false,
      }
    ],
  },
  {
    id: 10,
    name: 'Псевдоклассы элементов',
    answer: `
      <h2>1. Псевдоклассы состояния (Интерактив)</h2>
      <p>Эти селекторы реагируют на действия пользователя:</p>

      <ul>
          <li><code>:hover</code> — когда курсор мыши находится над элементом.</li>
          <li><code>:active</code> — момент клика (удержание кнопки мыши).</li>
          <li><code>:focus</code> — когда элемент выбран (например, через Tab или клик).</li>
          <li><code>:focus-visible</code> — срабатывает только при навигации с клавиатуры.</li>
      </ul>

      <h2>2. Структурные псевдоклассы</h2>
      <p>Помогают стилизовать элементы в зависимости от их положения в DOM:</p>

      <table>
          <thead>
              <tr>
                  <th>Псевдокласс</th>
                  <th>Описание</th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td><code>:first-child</code></td>
                  <td>Первый ребенок своего родителя.</td>
              </tr>
              <tr>
                  <td><code>:last-child</code></td>
                  <td>Последний ребенок своего родителя.</td>
              </tr>
              <tr>
                  <td><code>:nth-child(n)</code></td>
                  <td>Выбор по номеру или формуле (напр. 2n — четные).</td>
              </tr>
              <tr>
                  <td><code>:only-child</code></td>
                  <td>Если элемент — единственный ребенок.</td>
              </tr>
              <tr>
                  <td><code>:not(selector)</code></td>
                  <td>Исключение: выбирает всё, кроме указанного.</td>
              </tr>
          </tbody>
      </table>

      <h2>3. Продвинутые селекторы (Modern CSS)</h2>

      <p><code>:has()</code> — «родительский селектор». Позволяет стилизовать родителя, если внутри него есть определенный элемент.</p>

      <p>Пример: <code>div:has(img)</code> — выберет только те <code>div</code>, внутри которых есть картинка.</p>

      <p>
        <code>:is()</code> — группировка селекторов для чистоты кода.
        Он позволяет группировать селекторы вместо того чтобы перечислять длинные цепочки через запятую
      </p>

      <code class="code">
        /* Без :is() */
        .content h1,
        .content h2,
        .content h3,
        .section h1,
        .section h2,
        .section h3 {
          color: red;
        }

        /* С :is() */
        :is(.content, .section) :is(h1, h2, h3) {
          color: red;
        }
      </code>

      <p><code>:where()</code> — аналог <code>:is()</code>, но с нулевой специфичностью (легко перебивается другими стилями).</p>
    `,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Псевдоклассы состояния (Интерактив)',
        isChecked: false,
      },
      {
        name: 'Структурные псевдоклассы',
        isChecked: false,
      },
      {
        name: 'Продвинутые селекторы (Modern CSS)',
        isChecked: false,
      },
    ],
  },
  {
    id: 11,
    name: 'Псевдоклассы форм',
    answer: `
      <p><code>:disabled</code> — если поле заблокировано.</p>

      <p><code>:required</code> — если у поля есть атрибут обязательного заполнения.</p>

      <p><code>:invalid</code> / <code>:valid</code> — автоматическая проверка (например, если в type="email" введено что-то другое).</p>
      <p><code>:checked</code> — для выбранных чекбоксов и радиокнопок.</p>

      <p><code>:placeholder-shown</code> — стиль поля, пока в нем ничего не написано.</p>
    `,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: ':disabled, :required, :invalid, :valid, :checked, :placeholder-shown',
        isChecked: false,
      }
    ],
  },
  {
    id: 12,
    name: 'Псевдоэлементы',
    answer: `<span class="accent">Псевдоэлементы</span> — это способ стилизовать те части элемента, которых нет в HTML-разметке (в DOM-дереве), но которые браузер отрисовывает визуально.
    <h3>Основные виды псевдоэлементов</h3>
    Их довольно много, но в реальной работе ты будешь использовать эти 5-6 штук в 90% случаев:

    </br>

    1. Генерируемый контент (<code>::before</code> и <code>::after</code>)
    <p>Самые мощные инструменты верстальщика. Они создают виртуальный элемент, который находится внутри родителя, в самом начале (<code>::before</code>) или в самом конце (<code>::after</code>).</p>

    <p>Для чего: Иконки, декоративные элементы, хлебные крошки, кастомные чекбоксы, очистка потока (clearfix).</p>

    <p>Обязательное условие: Свойство content. Без него (даже если оно пустое <code>content: '';</code>) псевдоэлемент не появится.</p>
    2. Текстовые (<code>::first-letter</code> и <code>::first-line</code>)
    <p><code>::first-letter</code>: Стилизует первую букву блочного элемента (эффект буквицы в книгах).</p>

    <p><code>::first-line</code>: Стилизует первую строку текста. Учти, что длина строки зависит от ширины окна браузера, поэтому стили применяются динамически.</p>

    3. Интерфейсные
    <p><code>::placeholder</code>: Отвечает за стиль текста-подсказки в <code>input</code> и <code>textarea</code>.</p>

    <p><code>::selection</code>: То, как выглядит текст, когда пользователь выделяет его мышкой (обычно меняют <code>background</code> и <code>color</code>).</p>
    <p><code>::marker</code>: Стилизует маркеры (точки/цифры) в списках <code>ul</code> и <code>ol</code>.</p>

    <p>4. Продвинутые (реже используются, но полезны)</p>
    <p><code>::backdrop</code>: Фон, который появляется под элементами в полноэкранном режиме (например, под открытым <code>dialog</code> или видео).</p>
    <p><code>::file-selector-button</code>: Кнопка "Выберите файл" внутри <code>input type="file"</code>.</p>`,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Что такое псевдоэлементы?',
        isChecked: false,
      },
      {
        name: 'Генерируемый контент (::before и ::after)',
        isChecked: false,
      },
      {
        name: 'Текстовые (::first-letter и ::first-line)',
        isChecked: false,
      },
      {
        name: 'Интерфейсные (::placeholder, ::selection, ::marker)',
        isChecked: false,
      },
      {
        name: 'Продвинутые (::backdrop, ::file-selector-button)',
        isChecked: false,
      },
    ],
  },
  {
    id: 13,
    name: 'Позиционирование элементов (absolute, fixed, relative)',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 14,
    name: 'Типы элементов (строчные, блочные и т.д.). Их различия',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 15,
    name: 'Центрирование (горизонтальное, вертикальное)',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 16,
    name: 'Боксовая модель(Box Model) и box-sizing',
    answer: `
      <h3>Боксовая модель (Box Model): </h3>
      <p>В CSS каждый элемент на странице — это невидимая прямоугольная коробка (бокс).
      Эта коробка состоит из четырёх слоёв, которые идут изнутри наружу:</p>

      <ul>
        <li><strong>Content (Контент):</strong> Сама суть — текст, картинка или вложенные элементы.</li>
        <li><strong>Padding (Внутренний отступ):</strong> Пространство между контентом и границей. Фон элемента заливает и эту область.</li>
        <li><strong>Border (Граница/Рамка):</strong> Линия вокруг элемента (оборачивает контент и padding).</li>
        <li>
          <strong>Margin (Внешний отступ):</strong> Пустое пространство снаружи границы. Оно прозрачное и отодвигает нашу коробку
          от соседних элементов.
        </li>
      </ul>

      <h3>Свойство box-sizing: В чём главная проблема?</h3>
      <p>
        Свойство <code>box-sizing</code> решает классическую головную боль верстальщика: как именно вычисляется итоговый
        размер элемента на странице.
      </p>

      <h3>Существует два основных подхода:</h3>

      <p><strong>1. box-sizing: content-box (По умолчанию — "Старая школа")</strong></p>
      Как работает: Свойство width задаёт ширину только для контента.

      <p>
        В чём подвох: Если ты задал элементу ширину <code>100px</code>, а потом добавил внутренние отступы
        <code>padding: 10px</code> и рамку <code>border: 5px</code>, то реальная ширина элемента на экране станет <code>130px</code>
        (100 + 10 слева + 10 справа + 5 слева + 5 справа).
      </p>

      <p><strong>2. box-sizing: border-box (Современный стандарт — "Новая школа")</strong></p>
      <p>Как работает: Свойство width задаёт ширину всей коробки целиком (контент + padding + border).</p>

      <p>
        Решение: Если ты задал ширину <code>100px</code>, добавил паддинги и бордеры, элемент останется ровно
        <code>100px</code>. Браузер просто автоматически ужмёт зону контента внутри, чтобы всё поместилось
        в заданные габариты.
      </p>

      <h3>Стандарт де-факто</h3>

      <p>
        Как правило, в современной разработке используют <code>box-sizing: border-box</code>
        для всех элементов (он делает поведение всех элементов предсказуемым):
      </p>
      <code class="code">
        *, *::before, *::after {
          box-sizing: border-box;
        }
      </code>
    `,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Боксовая модель (Box Model)',
        isChecked: false,
      },
      {
        name: 'box-sizing: content-box и box-sizing: border-box',
        isChecked: false,
      },
    ],
  },
  {
    id: 17,
    name: 'Flexbox VS Grid',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Что такое Flexbox',
        isChecked: false,
      }
    ],
  },
  {
    id: 18,
    name: 'CSS анимации',
    answer: ``,
    tags: ['markup', 'CSS', 'animations'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 19,
    name: 'Сброс стилей и "нормализация" (Reset VS Normilize). Их различия.',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 20,
    name: 'Единицы измерения (em, rem, %, px, vh, vw)',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 21,
    name: 'Порядок подключения ресурсов. Скрипты в head, скрипты в конце body. В чем разница.',
    answer: `
      <p>Скрипты можно подключать в <code>&lt;head&gt;</code> или в конце <code>&lt;body&gt;</code>. Разница в том, когда они загружаются и выполняются.</p>
      <p>Если скрипт в <code>&lt;head&gt;</code>, он блокирует рендеринг страницы до загрузки и выполнения. Если в конце <code>&lt;body&gt;</code>, страница сначала загружается, а скрипт выполняется после.</p>
    `,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Порядок подключения ресурсов (скрипты в head, скрипты в конце body)',
        isChecked: false,
      }
    ],
  },
  {
    id: 22,
    name: 'Способы подключить JS на страницу',
    answer: `
      <h3>1. Внешний файл (наилучший способ)</h3>
      JS-код размещается в отдельном файле с расширением .js. Это помогает отделить логику от структуры.
      <code class="code">
        &lt;script src="path/to/script.js">&lt;/script>
      </code>

      <p>Рекомендуется использовать атрибуты defer (скрипт выполняется после загрузки HTML) или async (скрипт выполняется асинхронно,
      как только загрузится) для повышения производительности.</p>

      <code class="code">
        &lt;script src="script.js" defer>&lt;/script>
      </code>

      <h3>2. Встроенный скрипт (Inline JS)</h3>
      Код размещается непосредственно внутри HTML-документа между тегами &lt;script> и &lt;/script>.

      <code class="code">
        &lt;script>console.log('Привет, мир!')&lt;/script>
      </code>

      Можно размещать в &lt;head&gt; или в конце &lt;body&gt;.
      <h3>3. Инлайновый скрипт (в атрибутах HTML)</h3>
      Скрипт добавляется прямо в HTML-теги, обычно в обработчики событий (например, onclick, onmouseover).
      <code class="code">
        &lt;button onclick="alert('Нажали!')">Нажми меня&lt;/button>
      </code>
        * Не рекомендуется для больших скриптов, так как это усложняет поддержку кода.
    `,
    tags: ['HTML', 'markup', 'JavaScript'],
    structure: [
      {
        name: '3 способа подключения JS на страницу',
        isChecked: false,
      }
    ],
  },
  {
    id: 23,
    name: 'Атрибуты defer и async у тега script',
    answer: `

      <p class="info info--blue">
        Атрибуты async и defer не блокируют парсинг (загрузку и отрисовку) HTML-страницы.
      </p>

      </br>

      <p>
        Атрибуты <code>async</code> и <code>defer</code> у тега <code>&lt;script&gt;</code> используются для оптимизации загрузки внешних скриптов, предотвращая блокировку рендеринга страницы.
      </p>

      <p>
        <code>async</code> загружает скрипт асинхронно и выполняет его сразу после загрузки, не соблюдая порядок.
      </p>

      <p>
        <code>defer</code> загружает скрипт параллельно, но откладывает выполнение до полной готовности DOM-дерева, сохраняя порядок.
      </p>

      <h3>Основные отличия и применение:</h3>

      <p><strong>async (асинхронные):</strong><br>
        Скрипты не ждут друг друга и загружаются независимо. Идеальны для сторонних счетчиков, рекламы, аналитики
        (например, Google Analytics), когда скрипт не зависит от других файлов и не требует готовности DOM.
      </p>

      <p><strong>defer (отложенные):</strong><br>
        Скрипты выполняются последовательно, в том порядке, в котором они прописаны в HTML, перед событием
        <code>DOMContentLoaded</code>. Идеальны для скриптов, которым нужен доступ к DOM или зависимых друг от друга.
      </p>

      <p><strong>Без атрибутов:</strong><br>
        Браузер останавливает построение HTML, загружает и выполняет скрипт, что задерживает отображение страницы.
      </p>

      <p>
        Атрибуты работают только для внешних скриптов (при наличии <code>src</code>).
      </p>
    `,
    tags: ['HTML', 'markup', 'JavaScript'],
    structure: [
      {
        name: 'Async',
        isChecked: false,
      },
      {
        name: 'Defer',
        isChecked: false,
      },
      {
        name: 'Без атрибутов',
        isChecked: false,
      }
    ],
  },
  {
    id: 24,
    name: 'SVG. Анимации svg',
    answer: `
      <p>
        <strong>SVG (Scalable Vector Graphics)</strong> — это открытый формат двумерной векторной графики,
        основанный на XML, который описывает изображения с помощью линий, кривых, фигур и текста.
        В отличие от растровых форматов (<code>JPG</code>, <code>PNG</code>), SVG масштабируется
        без потери качества.
      </p>

      <p>
        SVG-файлы — это код, который можно редактировать, встраивать прямо в HTML, стилизовать
        с помощью CSS и анимировать через JavaScript или SMIL.
      </p>

      <h3>Ключевые особенности и анимация SVG:</h3>

      <ul>
        <li>
          <strong>Масштабируемость и четкость:</strong>
          изображения остаются резкими на любых экранах (Retina, мобильные устройства).
        </li>
        <li>
          <strong>Малый размер файла:</strong>
          обычно весят меньше растровых аналогов, так как состоят из текста.
        </li>
        <li>
          <strong>Интерактивность и анимация:</strong>
          <ul>
            <li>
              <strong>CSS:</strong> позволяет легко анимировать свойства, такие как
              <code>fill</code>, <code>stroke</code>, прозрачность, вращение и масштабирование.
            </li>
            <li>
              <strong>JavaScript:</strong> используется для сложной, интерактивной анимации
              (по клику, скроллу).
            </li>
            <li>
              <strong>SMIL (Synchronized Multimedia Integration Language):</strong>
              встроенные в SVG теги
              <code>&lt;animate&gt;</code>, <code>&lt;set&gt;</code>,
              <code>&lt;animateTransform&gt;</code>, позволяющие создавать анимацию
              внутри самого файла без использования внешних стилей.
            </li>
          </ul>
        </li>
      </ul>

    `,
    tags: ['SVG', 'markup', 'animations'],
    structure: [
      {
        name: 'Что такое SVG?',
        isChecked: false,
      },
      {
        name: 'Ключевые особенности SVG',
        isChecked: false,
      }
    ],
  },
  {
    id: 25,
    name: 'Canvas. Что это и зачем нужен?',
    answer: `
      <p>
        <strong>Canvas</strong> (с англ. «холст») в веб-разработке — это HTML5-элемент
        <code>&lt;canvas&gt;</code>, предназначенный для создания растровой графики, анимаций
        и визуализации данных непосредственно в браузере с помощью JavaScript.
      </p>

      <p>
        Если говорить проще, это пустая прямоугольная область на веб-странице, на которой
        JavaScript может «рисовать» линии, фигуры, текст и добавлять изображения,
        подобно художнику, рисующему на холсте.
      </p>

      <h3>Зачем нужен Canvas?</h3>

      <p>
        Canvas используется там, где обычные HTML-элементы и CSS не справляются из-за сложности
        или необходимости высокой производительности при динамическом изменении графики.
      </p>

      <h3>Основные сферы применения:</h3>

      <ul>
        <li><strong>Веб-игры:</strong> создание 2D и 3D игр, работающих прямо в браузере.</li>
        <li><strong>Визуализация данных:</strong> интерактивные графики, диаграммы, карты и сложные схемы.</li>
        <li><strong>Анимации:</strong> сложные визуальные эффекты и фоновые анимации.</li>
        <li><strong>Обработка изображений и видео:</strong> рендеринг видео в реальном времени, фотокомпозиции, фильтры.</li>
        <li><strong>Интерактивное рисование:</strong> создание приложений для рисования и редактирования изображений.</li>
      </ul>

      <h3>Преимущества Canvas</h3>

      <ul>
        <li><strong>Высокая производительность:</strong> эффективен для отрисовки большого количества объектов и частой смены кадров.</li>
        <li><strong>Гибкость:</strong> можно управлять каждым пикселем на экране.</li>
        <li><strong>Поддержка:</strong> работает во всех современных браузерах.</li>
      </ul>
    `,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Canvas - что это?',
        isChecked: false,
      },
      {
        name: 'Зачем нужен Canvas?',
        isChecked: false,
      },
      {
        name: 'Основные сферы применения',
        isChecked: false,
      },
      {
        name: 'Преимущества Canvas',
        isChecked: false,
      }
    ],
  },
  {
    id: 26,
    name: 'Custom properties',
    answer: `
      <p>
        <strong>Custom properties</strong> (пользовательские свойства CSS) — это CSS-переменные, определяемые пользователем,
        которые хранят специфические значения (цвета, размеры) для многократного использования в стилях. </br>
        Они начинаются с двойного дефиса (например, <code>--main-color: #000;</code>), чувствительны к регистру,
        поддерживают каскадирование, наследование и реактивно обновляются через функцию <code>var()</code>.
      </p>
    `,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Custom properties - что это?',
        isChecked: false,
      }
    ],
  },
  {
    id: 27,
    name: 'Pixel-perfect',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 28,
    name: 'Пре- и пост- процессоры CSS. Опыт работы с ними',
    answer: `
      <p>
        <span class="accent">Препроцессоры (Sass/SCSS, Less, Stylus) и постпроцессоры (PostCSS, Autoprefixer)</span> —
        это инструменты для автоматизации и расширения возможностей CSS. </br>
        Препроцессоры добавляют логику (переменные, миксины, вложенность) до написания стилей, а постпроцессоры оптимизируют и преобразуют готовый CSS (добавляют префиксы, минифицируют) после.
        </br>
        Их преимущества — ускорение верстки, улучшение читаемости кода и поддержка совместимости браузеров.
      </p>

      <p>
        Пре- и постпроцессоры CSS в 2025-2026 годах остаются актуальными, но их роль сильно изменилась. Если раньше они были обязательны для базового удобства, то сейчас они используются для сложной архитектуры, оптимизации и удобства разработчика, в то время как нативный CSS закрывает большинство потребностей.
      </p>
    `,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Пре- и пост- процессоры CSS - что это?',
        isChecked: false,
      },
      {
        name: 'Актуальность в 2025-2026 годах',
        isChecked: false,
      }
    ],
  },
  {
    id: 29,
    name: 'Методология БЭМ. Основные позиции, какие проблемы решает?',
    answer: `
      <h2>БЭМ (Блок-Элемент-Модификатор)</h2>

      <p>
        <strong>БЭМ («Блок-Элемент-Модификатор»)</strong> — это методология верстки и организации CSS-кода,
        разработанная компанией «Яндекс», которая делит интерфейс на независимые компоненты.
        Основная идея — использование структуры <code>block__element--modifier</code> для понятного
        именования классов, что решает проблемы с конфликтами стилей, значительно упрощает масштабирование,
        рефакторинг и повторное использование кода.
      </p>

      <h3>Основные позиции методологии БЭМ:</h3>

      <ul>
        <li>
          <strong>Блок (Block):</strong>
          функционально независимый компонент, который может быть повторно использован
          (например, <code>menu</code>, <code>button</code>, <code>form</code>).
          Класс блока не должен зависеть от других элементов страницы.
        </li>
        <li>
          <strong>Элемент (Element):</strong>
          составная часть блока, которая не может использоваться в отрыве от него
          (например, <code>menu__item</code>, <code>search-form__input</code>).
          Именуется через два подчеркивания.
        </li>
        <li>
          <strong>Модификатор (Modifier):</strong>
          определяет внешний вид, состояние или поведение блока/элемента
          (например, <code>menu__item--active</code>, <code>button--hidden</code>).
          Именуется через два дефиса.
        </li>
        <li>
          <strong>Именование классов:</strong>
          в основе лежит строгая система имен, исключающая использование селекторов по тегам
          или вложенности, что повышает читаемость кода.
        </li>
      </ul>

      <h3>Какие проблемы решает БЭМ:</h3>

      <ul>
        <li>
          <strong>Конфликты стилей (Specificity Wars):</strong>
          благодаря уникальным именам классов стили одного блока не перекрывают стили другого.
        </li>
        <li>
          <strong>Сложность поддержки (Supportability):</strong>
          понятная структура облегчает понимание кода, даже если он написан другим разработчиком
          или давно.
        </li>
        <li>
          <strong>Масштабируемость (Scalability):</strong>
          упрощает добавление новых элементов без риска «сломать» старые.
        </li>
        <li>
          <strong>Повторное использование (Reusability):</strong>
          блоки легко переносить между проектами или использовать в разных частях одного сайта.
        </li>
        <li>
          <strong>Хаос в именовании:</strong>
          устраняет использование случайных имен, создавая единый стандарт для всей команды.
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Методология БЭМ - что это?',
        isChecked: false,
      },
      {
        name: 'Основные позиции методологии БЭМ',
        isChecked: false,
      },
      {
        name: 'Какие проблемы решает БЭМ',
        isChecked: false,
      }
    ],
  },
  {
    id: 30,
    name: 'HTML-шаблонизаторы/препроцессоры (handlebars, mustache, pug etc)',
    answer: `
      <h2>Примеры популярных инструментов</h2>

      <ul>
        <li>
          <strong>Handlebars / Mustache:</strong>
          «логически простые» (logic-less) шаблонизаторы. Они фокусируются на вставке данных
          и разделении логики приложения и верстки.
          <strong>Handlebars</strong> — более мощная версия <strong>Mustache</strong>,
          поддерживающая вложенные пути данных и более сложные помощники (helpers).
        </li>
        <li>
          <strong>Pug:</strong>
          мощный препроцессор/шаблонизатор, использующий синтаксис на основе отступов
          (indentation-based). Идеален для уменьшения количества кода.
        </li>
        <li>
          <strong>EJS (Embedded JavaScript):</strong>
          позволяет использовать чистый JavaScript прямо внутри HTML-тегов
          <code>&lt;% %&gt;</code>.
        </li>
      </ul>

      <h3>В чем разница между шаблонизатором и препроцессором?</h3>

      <ul>
        <li>
          <strong>Шаблонизатор (Handlebars / Mustache):</strong>
          обычно работает на стороне сервера или клиента, подставляя данные
          в подготовленный HTML-файл.
        </li>
        <li>
          <strong>Препроцессор (Pug):</strong>
          сначала «компилирует» свой синтаксис в чистый HTML,
          а затем этот HTML уже отдается браузеру.
        </li>
      </ul>

      <h3>Актуальны ли они сегодня?</h3>

      <ul>
        <li>
          <strong>Handlebars / Mustache:</strong>
          все еще используются в проектах с серверной рендерингом (например, на Node.js),
          на фронте - крайне редко, уступив место более современным инструментам (React, Vue, Angular).
        </li>

        <li>
          <strong>Pug:</strong>
           В мире Node.js / Express — используется, но сдает позиции. В фронтенде — почти не используется, уступив место JSX (для React)
           и другим инструментам. В общем, сейчас это, можно сказать, нишевая история.
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup'],
    structure: [
      {
        name: 'HTML-шаблонизаторы/препроцессоры - что это?',
        isChecked: false,
      },
      {
        name: 'Примеры популярных инструментов',
        isChecked: false,
      },
      {
        name: 'В чем разница между шаблонизатором и препроцессором?',
        isChecked: false,
      },
      {
        name: 'Актуальны ли они сегодня?',
        isChecked: false,
      }
    ],
  },
  {
    id: 31,
    name: 'CORS. Что это такое и с чем его едят?',
    answer: ``,
    tags: ['browser', 'security'],
    structure: [
      {
        name: 'CORS - что это?',
        isChecked: false,
      }
    ],
  },
  {
    id: 32,
    name: 'Типы данных (задачи: строка + число)',
    answer: `
      <h2>Типы данных в JavaScript</h2>

      <p>
        В JavaScript есть <strong>8 основных типов данных</strong>.
      </p>

      <p>
        <strong>Семь из них называют «примитивными» типами данных:</strong>
      </p>

      <ul>
        <li>
          <strong>number</strong> — для любых чисел: целочисленных или чисел с плавающей точкой;
          целочисленные значения ограничены диапазоном
          <code>±(2<sup>53</sup> − 1)</code>.
        </li>
        <li>
          <strong>bigint</strong> — для целых чисел произвольной длины (обычно с n в конце: <code>123n</code>).
        </li>
        <li>
          <strong>string</strong> — для строк. Строка может содержать ноль или больше символов,
          отдельного символьного типа не существует.
        </li>
        <li>
          <strong>boolean</strong> — для значений <code>true</code> / <code>false</code>.
        </li>
        <li>
          <strong>null</strong> — для неизвестных значений; отдельный тип,
          имеющий одно значение <code>null</code>.
        </li>
        <li>
          <strong>undefined</strong> — для неприсвоенных значений; отдельный тип,
          имеющий одно значение <code>undefined</code>.
        </li>
        <li>
          <strong>symbol</strong> — для уникальных идентификаторов.
        </li>
      </ul>

      <p>
        <strong>И один тип не является «примитивным» и стоит особняком:</strong>
      </p>

      <ul>
        <li>
          <strong>object</strong> — для более сложных структур данных.
        </li>
      </ul>

      <h3>Оператор typeof</h3>

      <p>
        Оператор <code>typeof</code> позволяет узнать, какой тип данных сохранён в переменной.
      </p>

      <p>
        Он имеет две формы: <code>typeof x</code> или <code>typeof(x)</code>.
        Возвращает строку с именем типа, например <code>"string"</code>.
      </p>

      <p>
        Для значения <code>null</code> возвращается <code>"object"</code> —
        это историческая ошибка в языке, на самом деле <code>null</code> не является объектом.
      </p>

    `,
    tags: ['JavaScript', 'Data types'],
    structure: [
      {
        name: '7 примитивных типов данных',
        isChecked: false,
      },
      {
        name: '1 непримитивный тип данных',
        isChecked: false,
      },
      {
        name: 'Оператор typeof',
        isChecked: false,
      }
    ],
  },
  {
    id: 33,
    name: 'Преобразование (приведение) типов в JavaScript',
    answer: `
      <p>
        Существует <strong>3 наиболее широко используемых преобразования</strong>:
        строковое, численное и логическое.
      </p>

      <h3>Строковое преобразование</h3>

      <p>
        Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью
        <code>String(value)</code>. Для примитивных значений работает очевидным образом.
      </p>

      <h3>Численное преобразование</h3>

      <p>
        Происходит в математических операциях. Может быть вызвано с помощью
        <code>Number(value)</code>.
      </p>

      <p><strong>Преобразование подчиняется правилам:</strong></p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>Значение</th>
            <th>Становится…</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>undefined</code></td>
            <td><code>NaN</code></td>
          </tr>
          <tr>
            <td><code>null</code></td>
            <td><code>0</code></td>
          </tr>
          <tr>
            <td><code>true / false</code></td>
            <td><code>1 / 0</code></td>
          </tr>
          <tr>
            <td><code>string</code></td>
            <td>
              Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка,
              получаем <code>0</code>, иначе из непустой строки «считывается» число.
              При ошибке результат <code>NaN</code>.
            </td>
          </tr>
        </tbody>
      </table>

      <h3>Логическое преобразование</h3>

      <p>
        Происходит в логических операциях. Может быть вызвано с помощью
        <code>Boolean(value)</code>.
      </p>

      <p><strong>Подчиняется правилам:</strong></p>

      <table border="1" cellpadding="6" cellspacing="0">
        <thead>
          <tr>
            <th>Значение</th>
            <th>Становится…</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>""</code></td>
            <td><code>false</code></td>
          </tr>
          <tr>
            <td>любое другое значение</td>
            <td><code>true</code></td>
          </tr>
        </tbody>
      </table>

      <h3>Важные особенности</h3>

      <ul>
        <li>
          <code>undefined</code> при численном преобразовании становится <code>NaN</code>, а не <code>0</code>.
        </li>
        <li>
          <code>"0"</code> и строки из одних пробелов, например <code>" "</code>,
          при логическом преобразовании всегда дают <code>true</code>.
        </li>
      </ul>
    `,
    tags: ['JavaScript', 'Data types'],
    structure: [
      {
        name: 'Три основных типа преобразования',
        isChecked: false,
      }
    ],
  },
  {
    id: 34,
    name: 'Let, const и var. Различия + Hoisting ',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Let, const и var - различия',
        isChecked: false,
      },
      {
        name: 'Hoisting (всплытие или поднятие)',
        isChecked: false,
      }
    ],
  },
  {
    id: 35,
    name: 'Функции: function declaration, function expression',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics', 'functions'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 36,
    name: 'Структуры данных (массив, объект, set, map)',
    answer: `
      <h3>1. Массив (Array) []</h3>

      <p>
        Это упорядоченный список. В JavaScript массивы динамические и могут содержать
        данные разных типов (хотя TypeScript от этого отучает, и правильно делает).
      </p>

      <p><strong>Главная фишка:</strong> индексный доступ.</p>

      <p><strong>Сложность операций:</strong></p>

      <ul>
        <li><strong>Доступ по индексу</strong> (<code>arr[5]</code>): <code>O(1)</code> — мгновенно.</li>
        <li>
          <strong>Поиск значения</strong> (<code>indexOf</code>, <code>includes</code>, <code>find</code>):
          <code>O(n)</code> — чем больше массив, тем дольше поиск.
        </li>
        <li>
          <strong>Вставка/удаление в конце</strong> (<code>push</code>, <code>pop</code>):
          <code>O(1)</code>.
        </li>
        <li>
          <strong>Вставка/удаление в начале/середине</strong> (<code>shift</code>, <code>splice</code>):
          <code>O(n)</code> — движку нужно переиндексировать элементы.
        </li>
      </ul>

      <p class="info info--blue">
        <strong>Совет:</strong> используйте массивы, когда важен порядок элементов или
        когда нужно итерироваться по коллекции (например, рендеринг списков в UI).
        Если часто требуется поиск по ID — массив может быть плохим выбором.
      </p>

      <hr />

      <h3>2. Объект (Object) {}</h3>

      <p>
        Классическая Hash Map (словарь). До ES6 это был единственный способ хранения
        пар «ключ-значение».
      </p>

      <p><strong>Особенности:</strong></p>

      <ul>
        <li>
          Ключи всегда приводятся к строкам (или <code>Symbol</code>).
          Даже <code>obj[1]</code> превращается в <code>obj["1"]</code>.
        </li>
        <li>
          Нет встроенного итератора — используются
          <code>Object.keys()</code>, <code>Object.values()</code>.
        </li>
        <li>
          Сложность доступа, вставки и удаления по ключу:
          в среднем <code>O(1)</code>.
        </li>
      </ul>

      <p class="info info--blue">
        <strong>Совет:</strong> используйте объекты для хранения структурированных данных
        (например, профиль пользователя) или как простой справочник с фиксированными ключами.
        Не лучший выбор, если ключи динамические или коллекцию нужно часто перебирать.
      </p>

      <hr />

      <h3>3. Map (Карта) new Map()</h3>

      <p>
        Более продвинутый словарь, появившийся в ES6 для решения ограничений объектов.
      </p>

      <p><strong>Преимущества:</strong></p>

      <ul>
        <li>
          <strong>Любые ключи:</strong> ключом может быть объект, функция, DOM-узел и т.д.
        </li>
        <li>
          <strong>Порядок:</strong> сохраняется порядок вставки элементов.
        </li>
        <li>
          <strong>Размер:</strong> есть свойство <code>.size</code>.
        </li>
        <li>
          <strong>Производительность:</strong> оптимизирован для частых добавлений и удалений.
        </li>
      </ul>

      <code class="code">
        const cache = new Map();
        const user = { id: 1 };

        // Можно использовать объект как ключ
        cache.set(user, 'User Data');
      </code>

      <p class="info info--blue">
        <strong>Совет:</strong> если нужен кэш, словарь с частыми обновлениями
        или ассоциация метаданных с объектами — используйте <code>Map</code>.
      </p>

      <hr />

      <h3>4. Set (Множество) new Set()</h3>

      <p>
        Коллекция уникальных значений. Если добавить одно и то же значение несколько раз,
        оно будет храниться только один раз.
      </p>

      <p><strong>Главная фишка:</strong> быстрая проверка существования значения.</p>

      <p><strong>Сложность:</strong></p>

      <ul>
        <li>
          <strong>Проверка наличия</strong> (<code>set.has(value)</code>): <code>O(1)</code>.
        </li>
        <li>
          <strong>Добавление/удаление:</strong> <code>O(1)</code>.
        </li>
      </ul>

      <p class="info info--blue">
        <strong>Совет:</strong> частый кейс — удаление дубликатов из массива
        (<code>[...new Set(array)]</code>) и проверки прав доступа или ID.
        Вместо <code>array.includes(id)</code> внутри цикла (что даёт <code>O(n²)</code>),
        лучше создать <code>Set</code> и использовать <code>set.has(id)</code> —
        это значительно быстрее на больших данных.
      </p>

      <h3>5. WeakMap и WeakSet</h3>

      <p>
        <strong>WeakMap</strong> и <strong>WeakSet</strong> — это специальные коллекции в JavaScript, предназначенные
        для хранения объектов со «слабыми» ссылками. Они автоматически удаляют записи (ключи и значения),
        когда на объект не остаётся других ссылок, что предотвращает утечки памяти.
      </p>
    `,
    tags: ['JavaScript', 'Data types', 'Structures'],
    structure: [
      {
        name: 'Массив (Array)',
        isChecked: false,
      },
      {
        name: 'Объект (Object)',
        isChecked: false,
      },
      {
        name: 'Map (Карта)',
        isChecked: false,
      },
      {
        name: 'Set (Множество)',
        isChecked: false,
      },
      {
        name: 'WeakMap и WeakSet',
        isChecked: false,
      }
    ],
  },
  {
    id: 37,
    name: 'Основные методы массивов, которые вы используете',
    answer: `
      <p>
        Массивы предоставляют множество методов. Чтобы было проще, разобьем их на группы.
      </p>

      <h3>
        <strong>Добавление/удаление элементов</strong>
      </h3>

      <p>
        Базовые методы, которые добавляют и удаляют элементы из начала или конца:
      </p>

      <ul>
        <li><code>arr.pop()</code> - извлекает элемент из конца,</li>
        <li><code>arr.push(...items)</code> - добавляет элементы в конец,</li>
        <li><code>arr.shift()</code> - извлекает элемент из начала,</li>
        <li><code>arr.unshift(...items)</code> - добавляет элементы в начало.</li>
      </ul>

      <p>
        Но есть и другие методы для добавления и извлечения...
      </p>

      <h3>
        splice
      </h3>

      <p>
        Как удалить элементы из массива? Да, можно использовать метод delete (поскольку массивы - это тоже объекты).
        Но delete отработает не совсем корректно: он удалит значение элемента, но не сам элемент.
        А нам такое не подходит. Поэтому...
      </p>

      <p>
        Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами.
        Умеет всё: добавлять, удалять и заменять элементы.
      </p>

      <code class="code">
        arr.splice(index[, deleteCount, elem1, ..., elemN]);
      </code>

      <p>
        Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
        Возвращает массив из удалённых элементов.
      </p>

      <code class="code">
        let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

        // удалить 3 первых элемента и заменить их другими
        let removed = arr.splice(0, 3, "Давай", "танцевать");

        alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
        alert( removed ) // "Я", "изучаю", "JavaScript" <-- массив из удалённых элементов
      </code>

      <p class="info info--blue">
        В этом и в других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчёт элементов с конца.
      </p>

      <h3>
        slice
      </h3>

      <p>
        Метод arr.slice намного проще, чем похожий на него arr.splice.
      </p>
      <code class="code">
        arr.slice([start], [end]);
      </code>
      <p>
        Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
        Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
      </p>

      <code class="code">
        let arr = ["t", "e", "s", "t"];

        alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

        alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
      </code>

      <p class="info info--blue">
        Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr.
        Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.
      </p>

      <h3>
        concat
      </h3>

      <p>
        Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
      </p>
      <code class="code">
        arr.concat(arg1, arg2...);
      </code>

      <p>
        Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
      </p>
      <p>
        В результате мы получаем новый массив, включающий в себя элементы из <code>arr</code>,
        а также <code>arg1</code>, <code>arg2</code> и так далее&hellip;
      </p>
      <p>
        Если аргумент <code>argN</code> - массив, то все его элементы копируются. Иначе скопируется сам аргумент.
      </p>

      <code class="code">
        let arr = [1, 2];

        // создать массив из: arr и [3,4]
        alert( arr.concat([3, 4]) ); // 1,2,3,4

        // создать массив из: arr и [3,4] и [5,6]
        alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

        // создать массив из: arr и [3,4], потом добавить значения 5 и 6
        alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
      </code>

      <p>
        Обычно он просто копирует элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:
      </p>
      <code class="code">
        let arr = [1, 2];

        let arrayLike = {
          0: "что-то",
          length: 1
        };

        alert( arr.concat(arrayLike) ); // 1,2,[object Object]
      </code>

      <p>
        Но если объект имеет специальное свойство <code>Symbol.isConcatSpreadable</code>, то он обрабатывается
        <code>concat</code> как массив: вместо него добавляются его числовые свойства.
      </p>
      <p>Для корректной обработки в объекте должны быть числовые свойства и <code>length</code>:</p>
      <code class="code">
        let arr = [1, 2];

        let arrayLike = {
          0: "что-то",
          1: "ещё",
          [Symbol.isConcatSpreadable]: true,
          length: 2
        };

        alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
      </code>

      <h3>
        Перебор: forEach
      </h3>

      <p>
        Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
      </p>
      <code class="code">
        arr.forEach(function(item, index, array) {
          // ... делать что-то с item
        });
      </code>

      <p class="info info--blue">
        Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
      </p>

      <h3>
        <strong>Поиск в массиве</strong>
      </h3>

      <p>
        Методы arr.indexOf,  arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и
        делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:
      </p>

      <ul>
        <li>
          <code>arr.indexOf(item, from)</code> ищет <code>item</code>, начиная с индекса <code>from</code>,
          и возвращает индекс, на котором был найден искомый элемент, в противном случае <code>-1</code>.
        </li>
        <li>
          <code>arr.lastIndexOf(item, from)</code> - то же самое, но ищет справа налево.
        </li>
        <li>
          <code>arr.includes(item, from)</code> - ищет <code>item</code>, начиная с индекса <code>from</code>,
          и возвращает <code>true</code>, если поиск успешен.
        </li>
      </ul>

      <h3>
        find и findIndex
      </h3>

      <p>
        Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?
        Здесь пригодится метод arr.find.
      </p>
      <code class="code">
        let result = arr.find(function(item, index, array) {
          // если true - возвращается текущий элемент и перебор прерывается
          // если все итерации оказались ложными, возвращается undefined
        });
      </code>
      <p>
        Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент,
        а не сам элемент, и -1, если ничего не найдено.
      </p>

      <h3>
        filter
      </h3>
      <p>
        Метод find ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт true.
        На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn).
        </br>
        Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов:
      </p>
      <code class="code">
        let results = arr.filter(function(item, index, array) {
          // если true - элемент добавляется к результату, и перебор продолжается
          // возвращается пустой массив в случае, если ничего не найдено
        });
      </code>

      <h3>
        <strong>Преобразование массива</strong>
      </h3>

      <h3>
        map
      </h3>

      <p>
        Метод arr.map является одним из наиболее полезных и часто используемых.
      </p>
      <p>
        Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
      </p>
      <p class="info info--orange">
        Метод arr.map не изменяет исходный массив, а возвращает новый массив с результатами вызова функции для каждого элемента.
      </p>
      <code class="code">
        let result = arr.map(function(item, index, array) {
          // возвращается новое значение вместо элемента
        });
      </code>

      <p>
        Например, здесь мы преобразуем каждый элемент в его длину:
      </p>
      <code class="code">
        let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
        alert(lengths); // 5,7,6
      </code>

      <h3>
        sort(fn)
      </h3>
      <p>
        Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
      </p>
      <p class="info info--orange">
        Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам входной массив.
      </p>
      <code class="code">
        let arr = [ 1, 2, 15 ];

        // метод сортирует содержимое arr
        arr.sort();

        alert( arr );  // 1, 15, 2
      </code>

      <p>
        Не заметили ничего странного в этом примере?
        Порядок стал 1, 15, 2. Это неправильно! Но почему?
      </p>

      <p class="info info--blue">
        По умолчанию элементы сортируются как строки.
      </p>

      <p>
        Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
      </p>

      <p class="info info--blue">
        На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше»,
        и отрицательное число, чтобы сказать «меньше».
      </p>

      <p>
        Это позволяет писать более короткие функции:
      </p>
      <code class="code">
        let arr = [ 1, 2, 15 ];

        arr.sort( (a, b) => a - b );

        alert(arr);  // 1, 2, 15
      </code>

      <h3>
        reverse
      </h3>
      <p>
        Метод arr.reverse меняет порядок элементов в arr на обратный.
      </p>
      <p class="info info--orange">
        Метод arr.reverse мутирует входной массив arr. </br>
        Но также возвращает массив arr с изменённым порядком элементов.
      </p>
      <code class="code">
        let arr = [1, 2, 3, 4, 5];
        arr.reverse();

        alert( arr ); // 5,4,3,2,1
      </code>

      <h3>
        split и join
      </h3>
      <p>
        Методы-антагонисты. split делит строку на массив по заданному разделителю.
      </p>
      <code class="code">
        let names = 'Вася, Петя, Маша';

        let arr = names.split(', '); // ['Вася', 'Петя', 'Маша']
      </code>

      <p>
        У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве.
        Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:
      </p>
      <code class="code">
        let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

        alert(arr); // Вася, Петя
      </code>

      <p class="info info--blue">
        Вызов split(s) с пустым аргументом s разбил бы строку на массив букв и пробелов.
      </p>
      <code class="code">
        'ff f gggg hhhh'.split('');
          // ['f', 'f', ' ', 'f', ' ', 'g', 'g', 'g', 'g', ' ', 'h', 'h', 'h', 'h']
      </code>

      <p>
        Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя разделитель между ними.
      </p>
      <code class="code">
        let arr = ['Вася', 'Петя', 'Маша'];

        let str = arr.join(';'); // объединить массив в строку через: [Вася;Петя;Маша]
      </code>

      <h3>
        reduce/reduceRight
      </h3>
      <p>
        Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее.
        Они используются для вычисления какого-нибудь единого значения на основе всего массива.
      </p>
      <code class="code">
        let value = arr.reduce(function(previousValue, item, index, array) {
          // ...
        }, [initial]);
      </code>
      <p>
        Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.
      </p>
      <p>Аргументы:</p>

      <ul>
        <li>
          <code>previousValue</code> - результат предыдущего вызова этой функции, равен
          <code>initial</code> при первом вызове (если передан <code>initial</code>),
        </li>
        <li><code>item</code> - очередной элемент массива,</li>
        <li><code>index</code> - его индекс,</li>
        <li><code>array</code> - сам массив.</li>
      </ul>

      <p>
        При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.
        Он становится как-бы «аккумулирующим» результат предыдущих вызовов функции. По окончании он становится результатом reduce.
      </p>

      <p>
        Тут мы получим сумму всех элементов массива всего одной строкой:
      </p>
      <code class="code">
        let arr = [1, 2, 3, 4, 5];

        let result = arr.reduce((sum, current) => sum + current, 0); // result = 15
      </code>

      <h3>
        <strong>Array.isArray</strong>
      </h3>
      <p>
        Массивы не образуют отдельный тип языка. Они основаны на объектах.
        </br>
        Поэтому typeof не может отличить простой объект от массива:
      </p>
      <code class="code">
        alert(typeof {}); // object
        alert(typeof []); // тоже object
      </code>

      <p>
        …Но массивы используются настолько часто, что для этого придумали специальный метод:
        Array.isArray(value). Он возвращает true, если value массив, и false, если нет.
      </p>
      <code class="code">
        alert(Array.isArray({})); // false
        alert(Array.isArray([])); // true
      </code>

      <h3>
        <strong>Большинство методов поддерживают «thisArg»</strong>
      </h3>

      <p>
        Почти все методы массива, которые вызывают функции –
        такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg.
      </p>
      <code class="code">
        arr.find(func, thisArg);
          // thisArg - это необязательный последний аргумент
      </code>

      <p>
        Значение параметра thisArg становится this для func.
      </p>

      <h3>
        Источники:
      </h3>
      <ul>
        <li>
          <a href="https://learn.javascript.ru/array-methods#slice">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['JavaScript', 'Data types', 'Structures', 'Iterable', 'Array'],
    structure: [
      {
        name: 'pop/push и shift/unshift, их различия',
        isChecked: false,
      },
      {
        name: 'splice',
        isChecked: false,
      },
      {
        name: 'slice',
        isChecked: false,
      },
      {
        name: 'concat',
        isChecked: false,
      },
      {
        name: 'forEach',
        isChecked: false,
      },
      {
        name: 'indexOf/lastIndexOf и includes, их различия',
        isChecked: false,
      },
      {
        name: 'find и findIndex, их различия',
        isChecked: false,
      },
      {
        name: 'filter',
        isChecked: false,
      },
      {
        name: 'map',
        isChecked: false,
      },
      {
        name: 'sort(fn)',
        isChecked: false,
      },
      {
        name: 'reverse',
        isChecked: false,
      },
      {
        name: 'split и join',
        isChecked: false,
      },
      {
        name: 'reduce',
        isChecked: false,
      },
      {
        name: 'Array.isArray',
        isChecked: false,
      },
      {
        name: '«thisArg»',
        isChecked: false,
      },
    ],
  },
  {
    id: 38,
    name: 'Итераторы и генераторы',
    answer: `
      <h3>1. Итераторы: Механика под капотом</h3>
      <p>Если упростить, <span class="accent">Итератор</span> — это любой объект, который умеет сообщать, какой элемент идет следующим в
      последовательности. Это паттерн проектирования.</p>
      <p>В JavaScript (и многих других языках) объект считается итератором, если у него есть метод next(),
      который возвращает объект с двумя свойствами:</p>
      <ul>
        <li>value: текущее значение.</li>
        <li>done: булево значение (true, если перебор закончен).</li>
      </ul>
      <p>Вот как выглядит «ручной» итератор:</p>

      <code class="code">
        function createCounterIterator(start, end) {
          let count = start;
          return {
            next() {
              if (count <= end) {
                return { value: count++, done: false };
              }
              return { value: undefined, done: true };
            }
          };
        }

        const counter = createCounterIterator(1, 3);
        console.log(counter.next()); // { value: 1, done: false }
        console.log(counter.next()); // { value: 2, done: false }
        console.log(counter.next()); // { value: 3, done: false }
        console.log(counter.next()); // { value: undefined, done: true }
      </code>

      <p class="info info--blue">Проблема: Писать такие конструкции вручную для каждой задачи — долго, многословно и чревато ошибками.
      Здесь на сцену выходят генераторы.</p>

      <h3>2. Генераторы</h3>
      <p>
        <span class="accent">Генератор</span> — это специальная функция, которая может приостанавливать свое выполнение и
        возобновлять его позже. Она автоматически создает итератор за нас.
      </p>
      <p>Синтаксис отличается звездочкой: <code>function*</code>. Ключевое слово: <code>yield</code> (сдать, уступить).</p>
      <p>
        Когда интерпретатор доходит до <code>yield</code>, он «выплевывает» значение наружу и ставит функцию на паузу.
        Все переменные внутри функции замораживаются в памяти до следующего вызова <code>next()</code>.
      </p>

      <p>Тот же пример, но на генераторах:</p>

      <code class="code">
        function* counterGenerator(start, end) {
          for (let i = start; i <= end; i++) {
            yield i; // Функция замирает здесь и отдает i
          }
        }

        const counter = counterGenerator(1, 3);
        // Мы можем использовать for...of, так как генераторы — это итерируемые объекты
        for (const num of counter) {
          console.log(num); // 1, 2, 3
        }
      </code>

      <h3>3. Зачем это нужно на практике?</h3>
      <p>Может показаться, что обычного массива и map/forEach достаточно. Но генераторы незаменимы в трех случаях:</p>

      <h4>А. Работа с бесконечными данными</h4>
      <p>Массив с бесконечным количеством элементов положит память браузера или сервера.
      Генератор — нет, потому что он вычисляет значение только в тот момент, когда вы его попросили.</p>

      <h4>Б. Кастомный перебор сложных структур</h4>
      <p>Допустим, у тебя есть сложный объект (например, структура компании с отделами),
      и ты хочешь пробежаться по всем сотрудникам простым for...of. Ты можешь добавить свойство [Symbol.iterator]
      с генератором в этот объект.</p>

      <code class="code">
        const company = {
          name: "My Tech Corp",
          departments: [
            {
              name: "Frontend",
              staff: ["Alex", "Anna", "Dmitry"] // Массив строк для простоты
            },
            {
              name: "Backend",
              staff: ["John", "Sarah"]
            },
            {
              name: "QA",
              staff: [] // Пустой отдел
            }
          ],

          // ВОТ ОНА, МАГИЯ:
          // Этот генератор позволяет нам итерироваться по всем сотрудникам компании, независимо от их расположения в структуре
          // Когда сотрудники Frontend закончились, внутренний цикл генератора завершается, и он переходит к следующей итерации внешнего цикла
          *[Symbol.iterator]() {
            // 1. Пробегаем по отделам
            for (const dept of this.departments) {
              // 2. Пробегаем по сотрудникам внутри отдела
              for (const employee of dept.staff) {
                // 3. Отдаем сотрудника наружу и ЖДЕМ
                yield {
                  name: employee,
                  dept: dept.name
                };
              }
            }
          }
        };
      </code>

      <h4>В. Асинхронные потоки (Async/Await)</h4>
      <p>Это, пожалуй, самое важное. Механизм async/await, который мы используем каждый день, под капотом построен
      на идее генераторов (в связке с промисами). Генератор "ждет" (yield) промис, а когда тот резолвится, продолжает выполнение.</p>

      <p class="info info--blue">В повседневной практике редко используют function*,
      если только при работе со специфическими библиотеками вроде Redux-Saga (она вся построена на генераторах) или для
      сложных утилит обработки потоков данных. Однако понимание yield критически важно для глубокого
      понимания того, как работает асинхронность в JS.</p>

      <p class="info info--orange">
        Резюме по использованию <code>yield</code> и <code>next()</code>.
        </br>
        Ты пишешь <code>yield</code> внутри, чтобы сказать: "Я хочу вернуть вот это значение и подождать".
        </br>
        Ты пишешь <code>next()</code> снаружи, чтобы сказать: "Эй, просыпайся и работай до следующего yield!".
      </p>
    `,
    tags: ['JavaScript', 'Iterable', 'JS mechanics', 'Generators'],
    structure: [
      {
        name: 'Итераторы: Механика под капотом',
        isChecked: false,
      },
      {
        name: 'Генераторы',
        isChecked: false,
      },
      {
        name: 'Зачем это нужно на практике?',
        isChecked: false,
      }
    ],
  },
  {
    id: 39,
    name: 'Область видимости (Scope, Lexical Environment)',
    answer: `
      <p class="info info--orange">
        Разница между <span class="accent">Scope (Область видимости)</span> и <span class="accent">Lexical Environment
        (Лексическое окружение)</span> заключается в уровне абстракции. </br>
        Если коротко: <span class="accent">Scope</span> — это концепция, которая определяет, какие переменные доступны
        в определённой части кода,
        а <span class="accent">Lexical Environment</span> — это механизм (реализация под капотом),
        который обеспечивает работу этих правил.
      </p>


      <p>В JavaScript у каждой выполняемой функции, блока кода {...} и скрипта есть связанный с ними скрытый объект —
       Lexical Environment.</p>

      <h3>Lexical Environment состоит из двух частей:</h3>

      <p> - <strong>Environment Record</strong> — объект-хранилище, где лежат все локальные переменные (как свойства)
      и другая информация (например, значение this).</p>
      <p> - <strong>Ссылка на внешнее окружение</strong> — ссылка на лексическое окружение кода, который находится снаружи
      текущего (родительский контекст). Для глобального окружения эта ссылка равна null.</p>

      <p class="info info--blue">Важно: «Переменная» — это просто свойство специального внутреннего объекта Environment Record. Чтение или
      изменение переменной — это чтение или изменение свойства этого объекта.</p>

      <h3>Жизненный цикл переменной</h3>
      <p>Когда скрипт или функция начинают выполняться, лексическое окружение заполняется заранее.</p>

      <p>
        <strong>Фаза 1: Uninitialized</strong></br>
        Это особое внутреннее состояние. Движок знает о переменной, но к ней нельзя обратиться (это зона временной недоступности, TDZ).

        </br>
        Это почти то же самое, как если бы переменная не существовала.
      </p>

      <p>
        <strong>Фаза 2: Undefined</strong></br>
        Когда выполнение доходит до строчки <code>let x</code>, переменная получает значение <code>undefined</code>.
        </br>
        С этого момента мы можем использовать переменную.
      </p>

      <p><strong>Фаза 3: Присвоение</strong></br>
      Когда выполняется присвоение, значение в объекте окружения обновляется.</p>
    `,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Lexical Environment',
        isChecked: false,
      },
      {
        name: 'Виды областей видимости: глобальная, функциональная, блочная',
        isChecked: false,
      },
      {
        name: 'Жизненный цикл переменной',
        isChecked: false,
      }
    ],
  },
  {
    id: 40,
    name: 'Замыкание (Closure)',
    answer: `
      <h3>Простая модель (для понимания)</h3>

      <p>
        <strong>Замыкание — это функция с рюкзаком.</strong>
      </p>

      <p>
        Когда функция создаётся, она собирает в этот невидимый «рюкзак»
        все переменные, которые были вокруг неё в этот момент.
        Куда бы вы потом ни передали эту функцию и где бы ни вызвали —
        она всегда носит этот рюкзак с собой и может достать нужные данные.
      </p>

      <p class="info info--orange">
        В JavaScript практически все функции создаются с таким «рюкзаком»
        (кроме редкого случая с <code>new Function</code>).
      </p>

      <hr />

      <h3>Техническая механика (что происходит внутри)</h3>

      <p>
        Если копнуть глубже, важно запомнить два ключевых момента:
      </p>

      <ul>
        <li>
          <strong>Связь с местом создания:</strong>
          в момент создания каждая функция получает скрытое свойство
          <code>[[Environment]]</code>.
          Это ссылка на лексическое окружение (<em>Lexical Environment</em>),
          где она была объявлена.
        </li>
        <li>
          <strong>Поиск переменных по цепочке:</strong>
          когда функция обращается к переменной, она сначала ищет её внутри себя.
          Если не находит — идёт по ссылке <code>[[Environment]]</code> наружу,
          пока не дойдёт до глобальной области.
        </li>
      </ul>

      <p class="info info--blue">
        Именно благодаря <code>[[Environment]]</code> функция «помнит»,
        где она была создана, даже если вызывается в другом месте кода.
      </p>

      <h3>Практическая формулировка </h3>
      <p>
        При помощи замыкания в JavaScript годами создавали <span class="accent">«приватность»</span> и
        <span class="accent">«инкапсуляцию»</span> до того,как в классах появились приватные поля (#).

        </br>
        Замыкание позволяет спрятать переменную внутри функции так, чтобы снаружи к ней никто не мог прикоснуться,
        а работать с ней можно было только через специально созданные методы.
      </p>

      <h3>Формулировка для собеседования</h3>

      <p>
        <span class="accent">Замыкание:</span> это функция, которая запоминает свои внешние переменные
        и имеет к ним доступ, даже когда выполняется за пределами своей области видимости.
      </p>

      <p>
        <strong>Особенность JavaScript:</strong> в отличие от некоторых языков, в JavaScript функции
        автоматически обладают механизмом замыканий (кроме <code>new Function</code>).
      </p>
      <p>
        <strong>Механика</strong> - это работает через скрытое свойство <code>[[Environment]]</code>.
        При создании функция сохраняет ссылку на окружающую область видимости, поэтому при вызове она всегда имеет доступ
        к родительским данным.
      </p>

      <h3>*Важные моменты и уточнения</h3>

      <p>1. Что произойдёт, когда внешние переменные изменятся? Функция получит последнее значение или то,
      которое существовало на момент создания функции?</p>

      <p class="info info--blue">
        Замыкание хранит ссылку на переменную, а не её копию (снимок). Это значит, что функция всегда видит текущее (последнее) значение.
        Если переменная изменилась снаружи — функция увидит это изменение.
        </br>
        Аналогия: Это как ссылка на Google Doc. Если кто-то отредактировал документ,
        ты по своей ссылке увидишь новый текст, а не тот, что был в момент, когда тебе скинули ссылку.
      </p>

      <p> 2. Что произойдёт, когда функция переместится в другое место в коде и будет вызвана оттуда –
      получит ли она доступ к внешним переменным своего нового местоположения?</p>

      <p class="info info--blue">
        Нет, функция не получает доступ к переменным нового места (места вызова). Она «верна своему рождению».
        Она помнит только то место, где была создана (написана).
      </p>

    `,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Замыкание - что это и для чего нужно',
        isChecked: false,
      },
      {
        name: '[[Environment]]',
        isChecked: false,
      },
      {
        name: 'Использование замыканий для создания приватных переменных',
        isChecked: false,
      }
    ],
  },
  {
    id: 41,
    name: 'Сборщик мусора (Garbage Collector). Что это такое и для чего нужно?',
    answer: `
      <p>
        <span class="accent">Сборщик мусора (Garbage Collector, GC)</span> — это встроенный в движок JavaScript
        (например, V8 в Chrome) фоновый процесс, который автоматически управляет памятью.
      </p>

      <p>
        Это «уборщик», который ходит по памяти с какой-то периодичностью и удаляет то, что больше не нужно программе (недостижимые объекты),
        чтобы освободить место для новых данных.
      </p>

      <h3>Для чего он нужен?</h3>
      <p>
        Предотвращение утечек памяти: Если объекты создаются, но не удаляются, оперативная память (RAM)
        компьютера переполнится, и браузер/вкладка зависнет или «упадёт». GC предотвращает это (в большинстве случаев).
      </p>

      <h3>Как он работает?</h3>
      <p>Главная концепция управления памятью в JavaScript — Достижимость (Reachability).</p>
      <p>Если до объекта можно добраться по ссылкам от «корня» — он жив. Если нет — он удаляется.</p>
      <p>Нам не нужно вызывать GC вручную (и мы не можем), он запускается сам, когда движок решит, что это необходимо
      (обычно когда процессор не сильно загружен или памяти становится мало).</p>
    `,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Garbage Collector',
        isChecked: false,
      }
    ],
  },
  {
    id: 42,
    name: 'Рекурсия. Что это такое и для чего нужно?',
    answer: `
      <p>
        <span class="accent">Рекурсия</span> — это когда функция вызывает сама себя.
        Это мощный инструмент для решения задач, которые могут быть разбиты на похожие подзадачи.
      </p>

      <h3>Для чего нужна рекурсия на практике?</h3>

      <p>
        Рекурсия часто незаменима в работе с древовидными структурами данных. Полезна для решения задач,
        связанных с деревьями, графами, переборы массивов и других структур данных.
      </p>

      <h3>Плюсы рекурсии</h3>

      <p>
        - Читаемость: Код для обхода деревьев становится коротким и понятным.
      </p>

      <p>
        - Универсальность: Работает с любой глубиной вложенности.
      </p>

      <p>
        - Естественность: Рекурсия часто является самым естественным способом выразить алгоритмы, которые имеют
        рекурсивную природу (например, обход дерева).
      </p>

      <h3>Минусы рекурсии</h3>

      <p>
        - Сложность: могут быть сложными для понимания, добавляит когнитивную нагрузку.
      </p>

      <p>
        - Производительность: Каждый рекурсивный вызов занимает место в оперативной памяти (в стеке).
        </br>
        Рекурсия может быть медленнее итеративных решений из-за накладных расходов на вызов функции.
      </p>

      <p>
        - Ограничение глубины: В JavaScript есть ограничение на глубину рекурсии (обычно около 10 000 вызовов), после которого возникает
        ошибка "Maximum call stack size exceeded".
      </p>
    `,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Рекурсия - что это и для чего нужно',
        isChecked: false,
      },
      {
        name: 'Плюсы и минусы рекурсии',
        isChecked: false,
      }
    ],
  },
  {
    id: 43,
    name: 'Ключевое слово this. Контекст',
    answer: `
      <p class="info info--blue">
        <b>Главное правило <code>this</code></b></br>
        <span>
          Значение <code>this</code> определяется в момент вызова функции, а не в момент её создания
          (за исключением стрелочных функций).
        </span>
        </br>
      </p>

      <p>Чтобы понять, чему равен <code>this</code>, нужно посмотреть на то, как вызывается функция, а не где она написана.</p>

      <h3>1. Глобальный контекст и обычный вызов функции</h3>
      <p>Если функция вызывается сама по себе, без привязки к объекту:</p>

      <ul>
        <li>
          Без строгого режима (non-strict mode):
          <code>this</code> ссылается на глобальный объект (в браузере это <code>window</code>).
        </li>

        <li>В строгом режиме ("use strict"): <code>this</code> будет равен <code>undefined</code>.</li>
      </ul>

      <code class="code">
        function showContext() {
          console.log(this);
        }
        showContext(); // window или undefined (при "use strict")
      </code>

      <h3>2. Вызов в качестве метода объекта</h3>
      <p>Если функция вызывается как метод объекта (через точку), <code>this</code> указывает на объект, стоящий слева от точки.</p>
      <code class="code">
        const user = {
          name: 'Diuna',
          bark() {
            console.log(this.name);
          }
        };
        user.bark(); // 'Diuna', так как слева от точки находится user
      </code>

      <p>Опасность: потеря контекста Если передать метод как коллбэк или присвоить другой переменной, связь с объектом теряется.</p>

      <code class="code">
        const lostBark = user.bark;
        lostBark(); // undefined, так как вызывается просто как функция
      </code>

      <h3>3. Стрелочные функции (Arrow Functions)</h3>
      <p class="info info--orange">
        У стрелочных функций нет своего <code>this</code>.
      </p>
      <p>
        Стрелочные функции берут его из лексического окружения
        (внешней области видимости) в момент своего создания, и это значение больше никогда не меняется.
      </p>

      <code class="code">
        const group = {
          title: 'Frontend Team',
          showList() {
            setTimeout(() => {
              // this берется из showList, который указывает на group
              console.log(this.title);
            }, 1000);
          }
        };
      </code>
    `,
    tags: ['JavaScript', 'JS mechanics', 'context'],
    structure: [
      {
        name: 'Глобальный контекст и обычный вызов функции',
        isChecked: false,
      },
      {
        name: 'Вызов в качестве метода объекта',
        isChecked: false,
      },
      {
        name: 'Стрелочные функции (Arrow Functions)',
        isChecked: false,
      }
    ],
  },
  {
    id: 44,
    name: 'Привязка контекста (явная, неявная). Bind, call, apply и их различия',
    answer: `
      <h3>1. Неявная привязка (Implicit Binding)</h3>
      <p>
        Это самое частое поведение в коде, когда контекст определяется автоматически в зависимости от того,
        как вызвана функция. Главное правило неявной привязки: <code>this</code> указывает на объект,
        стоящий слева от точки при вызове.
      </p>

      <code class="code">
        const dog = {
          name: 'Diuna',
          bark() {
            console.log(\`\${ this.name } говорит гав!\`);
          }
        };

        // Неявная привязка: слева от точки находится объект dog

        dog.bark(); // Выведет: "Diuna говорит гав!"
      </code>

      <p>
        Главная проблема: Как только мы "отрываем" метод от объекта (например, передаем как коллбэк),
        неявная привязка ломается, и контекст теряется.
      </p>

      <h3>2. Явная привязка (Explicit Binding)</h3>

      <p>
        Когда нам нужно жестко сказать функции: "Выполняйся именно в этом контексте, независимо от того,
        как и где тебя вызывают", мы используем явную привязку. </br>
        Для этого у любой функции в JavaScript (потому что функции — это объекты)
        есть три встроенных метода: <code>call</code>, <code>apply</code> и <code>bind</code>.
      </p>

      <h4>📌 Метод <code>call</code></h4>
      <p>Метод call сразу же вызывает функцию с заданным контекстом и передает ей аргументы по одному через запятую.</p>

      <p>Синтаксис: <code>func.call(context, arg1, arg2, ...)</code></p>

      <code class="code">
        const car = { brand: 'Audi' };

        function drive(speed, destination) {
          console.log(\`Едем на \${ this.brand } со скоростью \${ speed } км / ч в \${ destination }\`);
        }

        // Вызываем функцию drive, принудительно указав this = car
        drive.call(car, 120, 'горы');
        // Выведет: "Едем на Audi со скоростью 120 км/ч в горы"
      </code>

      <h4>📌 Метод <code>apply</code></h4>
      <p>
        Делает абсолютно то же самое, что и call — сразу вызывает функцию.
        Единственное отличие: аргументы для функции передаются не списком, а одним массивом.
      </p>

      <p>Синтаксис: <code>func.apply(context, [arg1, arg2, ...])</code></p>

      <code class="code">
        // Результат будет идентичным что и в примере с .call()
        drive.apply(car, [120, 'горы']);
      </code>

      <h4>📌 Метод <code>bind</code></h4>
      <p>
        В отличие от <code>call</code> и <code>apply</code>, метод <code>bind</code> не вызывает функцию немедленно.
        Он создает и возвращает новую
        функцию, в которой контекст <code>this</code> привязан навсегда. Эту новую функцию можно вызвать позже.
      </p>

      <p>Синтаксис: <code>const boundFunc = func.bind(context, arg1, arg2, ...)</code></p>

      <code class="code">
        const driveMyCar = drive.bind(car);

        // Где-то в другом месте кода, даже как коллбэк в setTimeout:
        setTimeout(driveMyCar, 1000, 90, 'лес');
        // Выведет: "Едем на Audi со скоростью 90 км/ч в лес"
      </code>

      <p>
        Важный нюанс: Функцию, привязанную через <code>bind</code>, нельзя "перепривязать". Повторный вызов <code>bind()</code>
        или использование <code>call</code> на ней не изменят её изначальный <code>this</code>.
      </p>
    `,
    tags: ['JavaScript', 'JS mechanics', 'context'],
    structure: [
      {
        name: 'Неявная привязка (Implicit Binding)',
        isChecked: false,
      },
      {
        name: 'Явная привязка (Explicit Binding)',
        isChecked: false,
      },
      {
        name: 'Методы call, apply и bind и их различия',
        isChecked: false,
      }
    ],
  },
  {
    id: 45,
    name: 'Каррирование (Currying)',
    answer: `
      <p>
        <span class="accent">Каррирование</span> — продвинутая техника для работы с функциями.
        Это трансформация функции, которая принимает несколько аргументов,
        в последовательность функций, каждая из которых принимает только один аргумент.
      </p>

      <p>
        Простыми словами: мы превращаем вызов <code>f(a, b, c)</code> в вызов <code>f(a)(b)(c)</code>.
      </p>

      <p class="info info--blue">
         Каррирование позволяет создавать более специализированные функции из общих. </br>
         Это полезно для частичного применения и композиции функций.
      </p>

      <p>
        Каррирование не вызывает функцию сразу. Оно возвращает новую функцию, которая ждет следующий аргумент,
        пока не соберет их все.
      </p>

      <p class="info info--orange">
        Это работает благодаря замыканиям (closures) — каждая вложенная функция "запоминает"
        аргументы из внешней области видимости.
      </p>

      <code class="code">
        function curry(f) { // curry(f) выполняет каррирование
          return function(a) {
            return function(b) {
              return f(a, b);
            };
          };
        }

        // использование
        function sum(a, b) {
          return a + b;
        }

        let curriedSum = curry(sum);

        alert( curriedSum(1)(2) ); // 3
      </code>

      <p>
        Как вы видите, реализация довольна проста: это две обёртки.
      </p>

      <p>
        Более продвинутые реализации каррирования, как например <code>_.curry</code> из библиотеки <code>lodash</code>, возвращают
        обёртку, которая позволяет запустить функцию как обычным образом, так и частично.
      </p>

      <code class="code">
        function sum(a, b) {
          return a + b;
        }

        let curriedSum = _.curry(sum); // используем _.curry из lodash

        alert( curriedSum(1, 2) ); // 3, можно вызывать как обычно
        alert( curriedSum(1)(2) ); // 3, а можно частично
      </code>

      <h3>Зачем это нужно на практике?</h3>

      <p class="info info--blue">
        Главная суперсила каррирования — <span class="accent">частичное применение (partial application)</span>.</br>
        Это возможность зафиксировать часть аргументов и получить новую, более специфичную функцию, чтобы не дублировать код.
      </p>
    `,
    tags: ['JavaScript', 'JS mechanics', 'functions', 'closures'],
    structure: [
      {
        name: 'Каррирование - что это и для чего нужно',
        isChecked: false,
      },
      {
        name: 'Реализация каррирования',
        isChecked: false,
      },
      {
        name: 'Зачем это нужно на практике?',
        isChecked: false,
      }
    ],
  },
  {
    id: 46,
    name: 'Частичное применение (Partial Application)',
    answer: `
      <p>
        <span class="accent">Частичное применение</span> — это процесс создания новой функции путем
        фиксации (предустановки) одного или нескольких аргументов существующей функции.
      </p>
      <p>
        Простыми словами: у нас есть функция, принимающая несколько аргументов. Мы "замораживаем"
        часть из них и получаем новую функцию, которая принимает только оставшиеся аргументы.
      </p>

      <p class="info info--blue">
        Частичное применение основано на каррировании, но не требует всех аргументов.
      </p>

      <code class="code">
        function curry(f) { // curry(f) выполняет каррирование
          return function(a) {
            return function(b) {
              return f(a, b);
            };
          };
        }

        function sum(a, b) {
          return a + b;
        }

        const curriedSum = curry(sum);
        const plusTwo = curriedSum(2); // возвращает функцию, которая ждет второй аргумент

        alert( plusTwo(3) ); // 5
      </code>
    `,
    tags: ['JavaScript', 'JS mechanics', 'functions', 'closures'],
    structure: [
      {
        name: 'Частичное применение (основано на каррировании)',
        isChecked: false,
      },
      {
        name: 'Реализация частичного применения',
        isChecked: false,
      }
    ],
  },
  {
    id: 47,
    name: 'Псевдомассив arguments (почему он псевдомассив?)',
    answer: `
      <h3>Псевдомассив arguments</h3>

      <p>
        Внутри любой обычной функции (объявленной через <code>function</code>) автоматически доступен специальный
        объект <code>arguments</code>.
        </br>
        Он содержит все аргументы, которые были переданы в функцию при её вызове, независимо от того, сколько
        параметров было указано при её объявлении.
      </p>

      <code class="code">
        function showArgs() {
          console.log(arguments[0]); // 'Hello'
          console.log(arguments[1]); // 42
          console.log(arguments.length); // 2
        }

        showArgs('Hello', 42);
      </code>

      <h3>Почему он называется «псевдомассивом» (Array-like)?</h3>

      <p>
        Главная причина кроется в его прототипе. arguments выглядит и ведет себя как массив, но им не является.
      </p>


      <p><b>Что делает его похожим на массив:</b></p>
      <ul>
        <li>У него есть свойство length, а его элементы проиндексированы начиная с нуля (arguments[0], arguments[1]).</li>
        <li>Их можно перебирать в цикле for.</li>
      </ul>

      <p><b>Что делает его "псевдо":</b></p>
      <ul>
        <li>У него нет встроенных методов массива.</li>
        <li>Его прототипом является базовый Object, а не Array.prototype.</li>
        <li>Поэтому ты не можешь вызвать на нем .map(), .filter(), .reduce() или .forEach().</li>
      </ul>

      <h3>Arguments VS Arrow Functions</h3>

      <p class="info info--orange">
        Стрелочные функции не имеют своего объекта <code>arguments</code>
      </p>

      <p>
        Если ты обратишься к <code>arguments</code> внутри стрелочной функции,
        она попытается найти его во внешней области видимости (так же, как она ищет <code>this</code>).
      </p>

      <code class="code">
        function wrapper() {
          const arrow = () => console.log(arguments[0]);
          arrow(); // Выведет 'Test', взяв arguments из wrapper
        }
        wrapper('Test');
      </code>

      <h3>Современные альтернативы</h3>

      <p>
        В современном JavaScript объект <code>arguments</code> используется крайне редко.
        Ему на смену пришел <code>rest-оператор (...)</code>, который собирает все переданные аргументы сразу в настоящий массив.
      </p>

      <code class="code">
        // ...args — это полноценный массив прямо из коробки
        function modernArgs(...args) {
          return args.filter(x => x > 10);
        }
        modernArgs(5, 15, 20); // [15, 20]
      </code>
    `,
    tags: ['JavaScript', 'JS mechanics', 'functions'],
    structure: [
      {
        name: 'Псевдомассив arguments',
        isChecked: false,
      },
      {
        name: 'Почему он псевдомассив?',
        isChecked: false,
      },
      {
        name: 'Arguments VS Arrow Functions',
        isChecked: false,
      },
      {
        name: 'Современные альтернативы',
        isChecked: false,
      }
    ],
  },
  {
    id: 48,
    name: 'Директива "use strict"',
    answer: `
      <p class="info info--blue">
        <span class="accent">Директива "use strict" (Строгий режим)</span>
        </br>
        </br>
        <code>"use strict"</code> — это специальная директива, появившаяся в стандарте ES5. Она переводит движок
        JavaScript в так называемый строгий режим.
      </p>

      <p>
        Исторически JS создавался в спешке, и в нем было много "прощающих" особенностей
        (Брендан Эйх (Brendan Eich) разработал язык всего за 10 дней в 1995 году): язык пытался
        продолжить работу любой ценой, даже если код был написан с явными логическими дырами.
        Строгий режим был введен, чтобы навести порядок и не ломать обратную совместимость.
      </p>

      <h3>Зачем он нужен? (Главные изменения)</h3>
      <p>
        Включение строгого режима меняет ряд правил под капотом. Вот самые важные из них:
      </p>

      <ol>
        <li>
          <b>Запрет случайных глобальных переменных</b>
          </br>
          В обычном режиме, если ты просто присвоишь значение переменной (например, <code>userAge = 30;</code>),
          JS молча создаст глобальную переменную <code>window.userAge</code>.
          </br>
          В строгом же режиме это выбросит <code>ReferenceError</code>.
        </li>
        <li>
          <b>Безопасный this в обычных функциях</b>
          </br>
          В обычном режиме привязывает <code>this</code> к глобальному объекту (<code>window</code>).
          </br>
          В строгом режиме <code>this</code> будет равен undefined. Это защищает нас от случайного
          изменения глобальных переменных через <code>this.prop = ...</code>.
        </li>
        <li>
          <b>Запрет дублирования имен параметров</b>
          </br>
          В старом JS можно было написать <code>function sum(a, a, c)</code>. Движок просто перезаписывал первую a второй.
          </br>
          В строгом режиме это вызовет синтаксическую ошибку на этапе чтения кода.
        </li>
        <li>
          <b>Ошибки при записи в read-only свойства</b>
          </br>
          Попытка изменить свойство, которое было заморожено (через <code>Object.freeze</code>) или настроено только на чтение
          (через <code>Object.defineProperty</code>), в обычном режиме просто тихо игнорируется.
          </br>
          В строгом — падает с ошибкой <code>TypeError</code>.
        </li>
      </ol>


      <h3>Как включить строгий режим?</h3>

      <p>Директиву можно применять на двух уровнях:</p>

      <p>1. Глобально (для всего файла): Пишется самой первой строкой в скрипте (выше могут быть только комментарии).</p>

      <code class="code">
        "use strict";

        let name = "John";
        // Весь код ниже работает в строгом режиме
      </code>

      <p>2. Локально (только для одной функции): Пишется первой строкой внутри тела функции.</p>
      <code class="code">
        function strictFunction() {
          "use strict";
          // Здесь строгий режим
        }
      </code>
    `,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Директива "use strict" - что это и для чего нужно',
        isChecked: false,
      },
      {
        name: 'Главные изменения при включении строгого режима',
        isChecked: false,
      },
      {
        name: 'Как включить строгий режим?',
        isChecked: false,
      }
    ],
  },
  {
    id: 49,
    name: 'Преобразование объектов: toString и valueOf',
    answer: `
      <p>
        Когда объект участвует в математической операции или строковом выражении (например,
        <code>obj + 1</code> или <code>alert(obj)</code>),
        JavaScript автоматически пытается преобразовать его в примитив (строку, число или логическое значение).
      </p>
      <p>Для этого под капотом используются два старых добрых метода: <code>toString</code> и <code>valueOf</code>.</p>

      <p>
        Движок определяет «контекст» операции (так называемый hint — подсказку) и решает, какой метод вызвать первым.
        Контекст может быть строковым (<code>"string"</code>) или числовым (<code>"number"</code> / <code>"default"</code>).
      </p>

      <h3>Метод <code>toString()</code> (Строковый контекст)</h3>

      <p>
        Вызывается первым, если мы делаем с объектом что-то "строковое" (например, интерполяцию
        <code>\${obj}</code> или используем <code>String(obj)</code>).
      </p>

      <p>
        <strong>Поведение по умолчанию:</strong></br>
        У обычных объектов <code>toString()</code> возвращает строку <code>"[object Object]"</code>.
        </br>
        У массивов — склеивает элементы через запятую (поэтому <code>[1, 2].toString()</code> дает "1,2").
      </p>

      <h3>Метод <code>valueOf()</code> (Числовой контекст)</h3>
      <p>
        Вызывается первым, если операция математическая
        (например, <code>obj * 2</code>, <code>obj - 1</code> или явное приведение <code>Number(obj)</code>).
        Оператор сложения <code>+</code> тоже сначала пробует использовать числовой контекст.
      </p>

      <p>
        <strong>Поведение по умолчанию:</strong></br>
        У стандартных объектов метод <code>valueOf()</code> возвращает сам объект.
        А так как правило гласит, что результатом должен быть примитив, движок игнорирует этот результат и
        сразу переключается на <code>toString()</code>.
      </p>

      <p>
        Именно поэтому при <code>obj1 + obj2</code> мы получаем конкатенацию двух строк
        <code>"[object Object][object Object]"</code>.
      </p>

      <h3>Кастомизация поведения</h3>

      <p>
        Мы можем переопределить эти методы в нашем объекте, чтобы задать свое поведение при приведении к примитиву.
      </p>

      <code class="code">
        const user = {
          name: 'Diuna',
          toString() {
            return this.name;
          }
        };

        alert(user); // Выведет "Diuna" вместо "[object Object]"
      </code>

      <p>
        Так же можно переопределить <code>valueOf()</code>, если нам нужно, чтобы объект вел себя как число.
      </p>

      <p>
        На практике, если объекту переопределить только <code>toString()</code>,
        он будет использоваться для всех преобразований: и для строк, и для чисел.
        Движок не найдет нормального примитива в <code>valueOf()</code> и всегда будет откатываться к <code>toString()</code>.
      </p>

      <p class="info info--blue">
        В современном стандарте (ES6) появился более элегантный способ управлять приведением типов — системный символ
        <code>Symbol.toPrimitive</code>, который заменяет собой оба этих метода и описывает всю логику в одной функции.
      </p>
    `,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Преобразование объектов: toString и valueOf',
        isChecked: false,
      },
      {
        name: 'Как движок решает, какой метод вызвать первым',
        isChecked: false,
      },
    ],
  },
  {
    id: 50,
    name: 'Цикл событий (Event loop), microtasks, event queue',
    answer: ``,
    tags: ['JavaScript', 'Browser mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 51,
    name: 'Наследование',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 52,
    name: 'Ссылка __proto__. Что это и с чем его едят?',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 53,
    name: 'Свойство F.prototype и создание объектов через new',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 54,
    name: 'Promises. Зачем нужны? Какую проблему решали?',
    answer: `
      <p>
        <code>Promise</code> (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript
        (добавленный в ES6),
        который связывает «создающий» и «потребляющий» коды вместе. «Создающий» код может выполняться сколько потребуется,
        чтобы получить результат. А промис делает результат доступным для кода, который подписан на него, когда результат готов.
      </p>

      <p>
        Синтаксис создания <code>Promise</code>:
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // функция-исполнитель (executor)
          // "певец"
        });
      </code>

      <p>
        Функция, переданная в конструкцию <code>new Promise</code>, называется исполнитель (executor).
        Когда <code>Promise</code> создаётся, она запускается автоматически.
        Она должна содержать «создающий» код, который когда-нибудь создаст результат.
      </p>
      <p>
        Её аргументы <code>resolve</code> и <code>reject</code> – это колбэки, которые предоставляет сам JavaScript.
        Наш код – только внутри исполнителя.
      </p>

      <p>
        Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
      </p>
      <ul>
        <li><code>resolve(value)</code> - если работа завершилась успешно, с результатом <code>value</code>.</li>
        <li><code>reject(error)</code> - если произошла ошибка, <code>error</code> - объект ошибки.</li>
      </ul>

      <p>
        У объекта <code>Promise</code>, возвращаемого конструктором <code>new Promise</code>, есть внутренние свойства:
      </p>
      <ul>
        <li>
          <code>state</code> ("состояние") - вначале <code>&quot;pending&quot;</code> ("ожидание"),
          потом меняется на <code>&quot;fulfilled&quot;</code> ("выполнено успешно") при вызове
          <code>resolve</code> или на <code>&quot;rejected&quot;</code> ("выполнено с ошибкой") при вызове <code>reject</code>.
        </li>
        <li>
          <code>result</code> ("результат") - вначале <code>undefined</code>, далее изменяется на <code>value</code>
          при вызове <code>resolve(value)</code> или на <code>error</code> при вызове
          <code>reject(error)</code>.
        </li>
      </ul>

      <p>
        Так что исполнитель по итогу переводит promise в одно из двух состояний:
      </p>
      <img src="../assets/img/promise.jpg">

      <p>
        Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // эта функция выполнится автоматически, при вызове new Promise

          // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
          setTimeout(() => resolve("done"), 1000);
        });
      </code>

      <p>
        А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
          setTimeout(() => reject(new Error("Whoops!")), 1000);
        });
      </code>

      <p class="info info--blue">
        <strong>Может быть что-то одно: либо результат, либо ошибка</strong></br>
        Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.
      </p>

      <p class="info info--blue">
        <strong>Вызов resolve/reject сразу</strong></br>
        Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject,
        то есть через какое-то время. Но это не обязательно, resolve или reject могут быть вызваны сразу:
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // задача, не требующая времени
          resolve(123); // мгновенно выдаст результат: 123
        });
      </code>

      <h3>
        Потребители: then, catch, finally
      </h3>
      <p>
        Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»),
        которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов
        .then, .catch и .finally.
      </p>

      <h3>
        then
      </h3>
      <p>
        Наиболее важный и фундаментальный метод – .then.
      </p>
      <code class="code">
        promise.then(
          function(result) { /* обработает успешное выполнение */ },
          function(error) { /* обработает ошибку */ }
        );
      </code>
      <p>
        Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:
      </p>

      <h3>
        catch
      </h3>
      <p>
        Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента:
        <code>.then(null, errorHandlingFunction)</code>. Или можно воспользоваться методом
        <code>.catch(errorHandlingFunction)</code>, который сделает то же самое
      </p>
      <code class="code">
        let promise = new Promise((resolve, reject) => {
          setTimeout(() => reject(new Error("Ошибка!")), 1000);
        });

        // .catch(f) это то же самое, что promise.then(null, f)
        promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
      </code>

      <h3>
        finally
      </h3>

      <p>
        По аналогии с блоком <code>finally</code> из обычного <code>try {...} catch {...}</code>,
        у промисов также есть метод <code>finally</code>.
      </p>

      <p>
        Вызов <code>.finally(f)</code> похож на <code>.then(f, f)</code>, в том смысле, что <code>f</code>
        выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
      </p>

      <p>
        <code>finally</code> хорошо подходит для очистки, например остановки индикатора загрузки,
        его ведь нужно остановить вне зависимости от результата.
      </p>
      <code class="code">
        new Promise((resolve, reject) => {
          /* сделать что-то, что займёт время, и после вызвать resolve/reject */
        })
          // выполнится, когда промис завершится, независимо от того, успешно или нет
          .finally(() => остановить индикатор загрузки)
          .then(result => показать результат, err => показать ошибку)
      </code>

      <p>Но это не совсем псевдоним <code>then(f,f)</code>, как можно было подумать. Существует несколько важных отличий:</p>

      <ol>
        <li>
          <p>
            Обработчик, вызываемый из <code>finally</code>, не имеет аргументов. В <code>finally</code> мы не знаем, к
            ак был завершён промис. И это нормально, потому что обычно наша задача -
            выполнить "общие" завершающие процедуры.
          </p>
        </li>
        <li>
          <p>Обработчик <code>finally</code> "пропускает" результат или ошибку дальше, к последующим обработчикам.</p>
        </li>
      </ol>

      <h3>
        Цепочка вызовов
      </h3>
      <p>
        Общая нужда - выполнять две или более асинхронных операции одна за другой, причём каждая следующая начинается
        при успешном завершении предыдущей и использует результат её выполнения.
      </p>
      <code class="code">
        let promise = doSomething();

        doSomething()
          .then(result => doSomethingElse(result))
          .then(newResult => doThirdThing(newResult))
          .then(finalResult => {
            console.log('Итоговый результат: \${ finalResult }');
          })
          .catch(failureCallback);
      </code>

      <p class="info info--blue">
        <strong>Можно продолжить цепочку вызовов после ошибки</strong></br>
        Т.е. после catch, что полезно для выполнения новых действий даже
        после того, как действие вернёт ошибку в цепочке вызовов.
      </p>

      <code class="code">
        new Promise((resolve, reject) => {
          console.log('Начало');

          resolve();
        })
        .then(() => {
          throw new Error('Где-то произошла ошибка');

          console.log('Выведи это');
        })
        .catch(() => {
          console.log('Выведи то');
        })
        .then(() => {
          console.log('Выведи это, несмотря ни на что');
        });
      </code>
      <p>
        В результате получим:
      </p>
      <code class="code">
        Начало
        Выведи то
        Выведи это, несмотря ни на что
      </code>

      <p class="info info--blue">
        <strong>Можно строить такие цепочки и с finally.</strong></br>
        Обработчик <code>finally</code> "пропускает" результат или ошибку дальше, к последующим обработчикам.
      </p>

      <h3>
        Какую проблему решали промисы
      </h3>
      <p>
        До появления «обещаний» асинхронные задачи можно было решать с помощью функций обратного вызова или с помощью обработки событий.
        Универсальный подход к решению асинхронных задач – обработка событий.
        Вариант решения задач с помощью «обещаний», скорее, призван заменить подход к функциям обратного вызова.
      </p>

      <p>
        В использовании функций обратного вызова есть существенный недостаток с точки зрения организации кода: "callback hell".
        Этот недостаток заключается в том, что в функции обратного вызова есть параметр, который, в свою очередь,
        также является функцией обратного вызова – и так может продолжаться до бесконечности.
      </p>

      <p>
        Может образоваться несколько уровней таких вложенностей. Это приводит к плохому чтению кода и запутанности между вызовами
        функций обратного вызова. Это, в свою очередь, приведет к ошибкам. С такой структурой кода найти ошибки очень сложно.
      </p>

      <h3>
        Источники:
      </h3>
      <ul>
        <li>
          <a href="https://learn.javascript.ru/promise-basics">Источник 1 (теория)</a>
        </li>
        <li>
          <a href="https://habr.com/ru/company/zerotech/blog/317256/">Источник 2 (зачем нужны)</a>
        </li>
      </ul>
    `,
    tags: ['JavaScript', 'JS mechanics', 'Promise', 'Async'],
    structure: [
      {
        name: 'Что такое Promise, в какой версии ES появился',
        isChecked: false,
      },
      {
        name: 'Неизменность результата после завершения промиса',
        isChecked: false,
      },
      {
        name: 'then, catch, finally',
        isChecked: false,
      },
      {
        name: 'Цепочка вызовов',
        isChecked: false,
      },
      {
        name: 'Какую проблему решали промисы',
        isChecked: false,
      },
    ],
  },
  {
    id: 55,
    name: 'Promise chaining. Можно ли вызывать promise.then().finally().then() или promise.catch().then()? Что получим?',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics', 'Promise', 'Async'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 56,
    name: 'Try - Catch. Что это и для чего нужно?',
    answer: ``,
    tags: ['JavaScript'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 57,
    name: 'Что нового появилось в языке в ES6?',
    answer: ``,
    tags: ['JavaScript', 'ES6'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 58,
    name: 'Что нового появилось в языке ПОСЛЕ ES6?',
    answer: ``,
    tags: ['JavaScript', 'ES6', 'ES7'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 59,
    name: 'Async await. Кто такие и какую проблему решают?',
    answer: ``,
    tags: ['JavaScript', 'ES6', 'Promise', 'Async'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 60,
    name: 'DOM. Что это и зачем нужно?',
    answer: ``,
    tags: ['HTML', 'markup', 'browser mechanics', 'browser'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 61,
    name: 'DOM события. Всплытие, погружение. Делегирование',
    answer: ``,
    tags: ['markup', 'browser mechanics', 'browser'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 62,
    name: 'LocalStorage VS SessionStorage. Различия, принцип работы',
    answer: ``,
    tags: ['markup', 'browser', 'LocalStorage', 'SessionStorage'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 63,
    name: 'Code style. Linters. Prittier',
    answer: ``,
    tags: ['programming', 'codestyle', 'best-practice'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 64,
    name: 'Мутабильность/иммутабильность (при работ с массивами etc)',
    answer: ``,
    tags: ['programming', 'immutable'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 65,
    name: 'Реактивное программирование. RxJs и основные методы',
    answer: `
      <h3>Реактивное программирование — программирование с асинхронными потоками данных.</h3>

      <p>
        Впрочем, ничего нового. Event bus’ы или обычные события клика — это тоже асинхронные потоки данных,
        которые вы можете прослушивать, чтобы реагировать какими-либо действиями.
        <br>
        <span class="accent">Реактивность</span> — это та же самая идея,
        возведенная в абсолют. Вы можете создавать потоки данных не только из событий наведения или кликания мышью.
        Потоком может быть что угодно: переменные, пользовательский ввод, свойства, кэш, структуры данных и т.п.
        <br>
        Например, представьте, что ваша лента новостей в Твиттере — поток событий. Вы можете слушать этот поток и
        реагировать на события соответственно.
      </p>

      <p>
        <span class="accent">Поток</span> — это последовательность событий, упорядоченная по времени. Он может выбрасывать три типа данных:
        значение (определенного типа), ошибку или сигнал завершения.
        <br>
        Мы перехватываем эти события асинхронно, указывая одну функцию, которая будет вызываться,
        когда выброшено значение, другую для ошибок и третью для обработки сигнала завершения.
      </p>

      <h3>Для чего нужно реактивное программирование</h3>

      <p>
        Реактивный подход повышает уровень абстракции вашего кода и вы можете сконцентрироваться на взаимосвязи событий,
        которые определяют бизнес-логику, вместо того, чтобы постоянно поддерживать код с большим количеством деталей реализации.
        Код в реактивном программировании, вероятно, будет короче.
      </p>

      <p>
        Преимущество более заметно в современных веб- и мобильных приложениях, которые работают с большим количеством
        разнообразных UI-событий. 10 лет назад всё взаимодействие с веб-страницей сводилось к отправке больших форм на
        сервер и выполнении простого рендеринга в клиентской части. Сейчас приложения более сложны: изменение одного поля может
        повлечь за собой автоматическое сохранение данных на сервере, информация о новом «лайке» должна отправиться
        другим подключенным пользователям и т.д.
      </p>

      <p>
        Реактивное программирование очень хорошо подходит для обработки большого количества разнообразных событий.
      </p>

      <h3>
        О библиотеке RxJs
      </h3>

      <p>
        <span class="accent">RxJS</span> представляет собой библиотеку, позволяющую управлять всеми асинхронными операциями и событиями в
        приложении в стиле реактивного программирования. Она построена на основе паттерна проектирования <code>Observer</code>
        и предусматривает целый ряд операторов для манипуляции асинхронными событиями и обработки передаваемых ими данных.
      </p>

      <h3>
        Ключевые понятия RxJS:
      </h3>

      <ul>
        <li><code>Observable</code>;</li>
        <li><code>Observer</code>;</li>
        <li><code>Subject</code>;</li>
        <li><code>Scheduler</code>;</li>
        <li><code>Subscription</code>;</li>
        <li><code>Operator</code>.</li>
      </ul>

      <p>
        RxJS оперирует объектами <code>Observable</code>, которые существуют в нескольких разновидностях
        (<code>Subject</code>, <code>Scheduler</code>) и реализуют принцип push-систем передачи данных от &quot;поставщика&quot;
        к &quot;потребителю&quot;.
      </p>

      <p>
        Помимо push-систем выделяют еще и pull-системы передачи данных.
      </p>

      <p>
        В pull-системах "потребитель" решает, когда получить данные от "поставщика".
        Любая JavaScript функция - яркий пример такой системы. Код вызова функции - "потребитель", сама функция - "поставщик".
      </p>

      <p>
        В случае с RxJS <code>Observable</code> именно отправитель решает, когда отправить данные получателю.
        К этому типу push-систем относятся и объекты <code>Promise</code>, которые предоставляют данные зарегистрированным
        callback-функциям и инициируют их вызов.
      </p>

      <p class="info info--blue">
        Преимущество объектов <code>Observable</code> в том, что они могут передавать данные множество раз в разные моменты
        времени множеству "потребителей".
      </p>

      <p>
        В контексте приложений Angular RxJS применяется для выполнения HTTP-запросов,
        отслеживания событий браузера или создания пользовательских и других событий.
      </p>

      <p>
        Пример создания простого Observable с использованием функции fromEvent:
      </p>

      <code class="code">
        import { fromEvent } from 'rxjs';

        fromEvent(document, 'mousemove').subscribe((ev) => {
          console.log('Mouse event: ', ev);
        });
      </code>

      <p>
        Здесь регистрируется обработчик, который при движении мыши в пределах всего документа в консоль будет
        выводить полную информации о событии.
      </p>
    `,
    tags: ['TypeScript', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 66,
    name: 'Что такое объект Observable в RxJs?',
    answer: `
      <code><em>Observable</em></code> — это последовательность событий во времени.

      <p>
        В RxJS зритель подписывается на <code>Observable</code> (зрелище).
        Подписавшийся зритель реагирует на каждое событие, которое происходит во время зрелища.
      </p>
      <p>
        Объекты RxJS <code>Observable</code> создаются либо с использованием операторов создания
        (<code>of</code>, <code>from</code>, <code>fromEvent</code>), либо через <code>new Observable</code>.
      </p>
      <p>
        Пример с оператором <code>of()</code>:
      </p>
      <code class="code">
        of('Hello').subscribe((vl) => console.log(vl));
      </code>

      <p>
        Пример с <code>new Observable</code>:
      </p>
      <code class="code">
        const obs = new Observable((sub) => {
          sub.next(1);

          setTimeout(() => {
            sub.next(3);
            sub.complete();
          }, 500);
        });

        obs.subscribe((vl) => console.log(vl));
      </code>
      <p>
        Каждый <code>Observable</code> может отправлять своим "зрителям" уведомления вызовом одного из трех методов:
      </p>
      <ul>
        <li> <code>next()</code> - отправка данных, количество вызовов не ограничено;</li>
        <li>
          <code>error()</code> - генерация ошибки, параметром указываются данные любого формата
          (строка, объект, исключение) о причине ее возникновения;
        </li>
        <li>
          <code>complete()</code> - завершение исполнения <code>Observable</code>, не принимает
          никаких параметров и не передает никакого значения.
        </li>
      </ul>

      <p>
        Но исполнение RxJS <code>Observable</code> начнется только после вызова у него метода <code>subscribe()</code>,
        который принимает функцию с передаваемыми данными в качестве аргумента.
        Вторым и третьим необязательными параметрами методу <code>subscribe()</code> можно передать функции,
        которые будут вызваны в случае ошибки или (и) завершения <code>Observable</code>.
      </p>
      <code class="code">
        const obs = new Observable((sub) => {
          sub.next(1);

          setTimeout(() => {
            sub.error(3);
          }, 500);
        });

        obs.subscribe(
          (vl) => console.log(vl),
          (err) => console.log('Error: ', err),
          () => console.log('Completed')
        );
      </code>
      <p class="info info--blue">
        Вызов <code>error()</code> или <code>complete()</code> автоматически завершает исполнение <code>Observable</code>.
      </p>
      <p>
        Количество вызовов исполнения такого объекта не ограничено, а сам он даже не знает, сколько "зрителей" получает от него данные.
      </p>
      <p>
        Метод <code>subscribe()</code> возвращает объект типа <code>Subscription</code>, который хранит текущее исполнение
        конкретного RxJS <code>Observable</code> и имеет единственный метод <code>unsubscribe()</code>
        для отмены его исполнения.
      </p>
      <code class="code">
        const sub = obs.subscribe();
        sub.unsubscribe();
      </code>
      <p>
        Вызов <code>unsubscribe()</code> нужен только для бесконечно исполняемых
        <code>Observable</code>, иначе занимаемые ими ресурсы будут освобождены только с окончанием
        работы всего приложения. А значит в процессе работы программы может произойти утечка памяти
        или могут быть созданы ненужные дублирующиеся "зрители".
      </p>
      <p>
        Например, последнее может произойти, когда пользователь зашел на страницу, инициирующую исполнение
        RxJS <code>Observable</code>, затем перешел на другой URL и вернулся обратно.
      </p>
      <p>
        Бесконечно исполняемыми <code>Observable</code> считаются те из них, которые никогда не вызывают метод
        <code>complete()</code>, даже если у них предусмотрен сценарий, при котором произойдет обращение к
        <code>error()</code>, что также завершит исполнение.
      </p>
      <p class="info info--blue">
        В Angular приложении <code>unsubscribe()</code> обычно вызывается на
        стадии жизненного цикла <code>OnDestroy()</code> того компонента, в котором используется <code>Observable</code>.
      </p>
    `,
    tags: ['TypeScript', 'Observables', 'Async', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 67,
    name: 'Что такое Subject? Какие бывают виды?',
    answer: `
      <h3>Что такое Subject</h3>

      <p>
        <span class="accent">Subject</span> - это разновидность объектов <code>Observable</code> в RxJS.
        <code>Subject</code> одновременно является и зрителем и зрелищем - соответственно, имеет методы как зрелища, так и зрителя.
        <br>
        Особенность <code>Subject</code> в том, что он может отправлять данные одновременно множеству "потребителей",
        которые могут регистрироваться уже в процессе исполнения <code>Subject</code>,
        в то время как исполнение стандартного <code>Observable</code> осуществляется уникально для каждого его вызова.
      </p>

      <p>
        Объекты RxJS Subject реализуют принцип работы событий, поддерживая возможность регистрировать неограниченное
        количество обработчиков отправляемых ими данных.
      </p>

      <p>
        Рассмотрим пример.
      </p>

      <code class="code">
        const sbj = new Subject<number>();

        sbj.subscribe((vl) => console.log('1st: $\{ vl }'));
        sbj.next(3);
        sbj.subscribe((vl) => console.log('2nd: $\{ vl }'));
        sbj.next(9);

        /*
        Результат  в консоли:

        1st: 3
        1st: 9
        2nd: 9
        */
      </code>

      <p>
        Создание происходит с помощью <code>new Subject()</code>. Далее регистрируются обработчики вызовом метода
        <code>subscribe()</code>, принимающего подобно обычному <code>Observable</code> три функции:
        <code>next()</code>, <code>error()</code> и <code>complete()</code>.
      </p>

      <p>
        Но здесь обработчики исполняются не сразу в момент вызова <code>subscribe()</code>,
        а после обращения к методам <code>next()</code>, <code>error()</code> или
        <code>complete()</code> самого объекта.
      </p>

      <p>
        Причем регистрация новых "потребителей" может происходить в любой момент времени. Но получать данные они
        будут уже начиная со следующей рассылки.
      </p>

      <p class="info info--blue">
        Объекты RxJS Subject по умолчанию являются бесконечно исполняемыми, так как заранее неизвестно,
        когда будет вызов complete() и будет ли он вызван вообще. Поэтому не стоит забывать про unsubscribe().
      </p>

      <h3>В RxJS имеется несколько разновидностей Subject</h3>
      <ul>
        <li><a href="https://rxjs.dev/api/index/class/BehaviorSubject"><code>BehaviorSubject</code></a>,</li>
        <li><a href="https://rxjs.dev/api/index/class/ReplaySubject"><code>ReplaySubject</code></a>,</li>
        <li><a href="https://rxjs.dev/api/index/class/AsyncSubject"><code>AsyncSubject</code></a>.</li>
      </ul>

      <h3>BehaviorSubject</h3>

      <p>
        <code>BehaviorSubject</code> хранит в себе последнее отправленное им значение.
        Так, каждому новому обработчику в момент регистрации (вызов <code>subscribe()</code>) будет отправлено это значение.
      </p>

      <p>
        Начальное значение задается в момент создания RxJS <code>BehaviorSubject</code>.
      </p>

      <code class="code">
        const sbj = new BehaviorSubject<number>(5);

        sbj.subscribe((vl) => console.log('1st: $\{ vl }'));
        sbj.subscribe((vl) => console.log('2nd: $\{ vl }'));
        sbj.next(7);

        /*
        Результат  в консоли:

        1st: 5
        2nd: 5
        1st: 7
        2nd: 7
        */
      </code>

      <h3>ReplaySubject</h3>

      <p>
        В отличие от <code>BehaviorSubject</code> объекты <code>ReplaySubject</code>
        способны хранить заданное количество последних значений, которое задается при создании объекта.
      </p>

      <code class="code">
        const sbj = new ReplaySubject(2);
        /*
          Внимание! Цифра 2 в скобках - количество последних обновлений, которые получит новый подписчик.
          Если его убрать, то будут продублированы все, а так - только 2 последних
        */

        sbj.next(5);

        sbj.subscribe((vl) => console.log('1st: $\{ vl }'));

        sbj.next(6);
        sbj.next(7);

        sbj.subscribe((vl) => console.log('2nd: $\{ vl }'));

        /*
        Результат  в консоли:

        1st: 5
        1st: 6
        1st: 7
        2nd: 6
        2nd: 7
        */
      </code>

      <p>
        Все новые "потребители" сразу же получают по очереди все
        <code>n</code> (в данном случае - 2) указанных значений RxJS <code>ReplaySubject</code>.
      </p>

      <h3>AsyncSubject</h3>

      <p>
        В случае с <code>AsyncSubject</code> "потребителям" передается только последнее значение объекта и
        только, когда он завершит свое выполнение (вызов <code>complete()</code>).
      </p>

      <code class="code">
        const sbj = new AsyncSubject();

        sbj.subscribe((vl) => console.log('Async: $\{ vl }'));

        sbj.next(7);
        sbj.next(8);
        sbj.next(9);

        setTimeout(() => sbj.complete(), 3000);

        /*
        Результат  в консоли (по истечении 3 сек):

        Async: 9
        */
      </code>
    `,
    tags: ['TypeScript', 'Observables', 'Async', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 68,
    name: 'Observables VS Subject - различия',
    answer: `
      <p>
        <span class="accent">Subject</span> - это разновидность объектов <code>Observable</code> в RxJS.
        <code>Subject</code> одновременно является и зрителем и зрелищем - соответственно, имеет методы как зрелища, так и зрителя.
        <br>
        Особенность <code>Subject</code> состоит в том, что здесь обработчики исполняются не сразу в момент вызова
        <code>subscribe()</code>, а после обращения к методам <code>next()</code>, <code>error()</code> или
        <code>complete()</code> самого объекта.
      </p>

      <p>
        <code>Subject</code> имеет несколько типов, поведение которых отличается между собой.
        Соответственно, их использование зависит от конкретных целей.
      </p>

      <ul>
        <li>
          <a href="https://rxjs.dev/api/index/class/BehaviorSubject"><code>BehaviorSubject</code></a> -
          хранит в себе последнее отправленное им значение.
        </li>
        <li>
          <a href="https://rxjs.dev/api/index/class/ReplaySubject"><code>ReplaySubject</code></a> -
          способны хранить заданное количество последних значений, которое задается при создании объекта.
        </li>
        <li>
          <a href="https://rxjs.dev/api/index/class/AsyncSubject"><code>AsyncSubject</code></a> -
          возвращает только последнее значение объекта и только, когда он завершит свое выполнение (вызов complete()).
        </li>
      </ul>

      <p>
        <span class="accent">Observable</span> - это просто некоторый асинхронный поток данных.
        <br>
        Данный механизм позволяет создавать объекты, инициирующие асинхронные потоки (stream или observable)
        и объекты, которые за ними наблюдают (observer).
      </p>

      <code class="code">
        import { Observable } from 'rxjs';

        const observable = new Observable(subscriber => {
          subscriber.next(1);
          subscriber.next(2);
          subscriber.next(3);
          setTimeout(() => {
            subscriber.next(4);
            subscriber.complete();
          }, 1000);
        });

        console.log('just before subscribe');
        observable.subscribe({
          next(x) { console.log('got value ' + x); },
          error(err) { console.error('something wrong occurred: ' + err); },
          complete() { console.log('done'); }
        });

        console.log('just after subscribe');
      </code>

      <p>
        Выполнение кода, описанного выше, выведет в консоли следующее:
      </p>

      <code class="code">
        just before subscribe
        got value 1
        got value 2
        got value 3
        just after subscribe
        got value 4
        done
      </code>

      <h3>
        Подытожим.
      </h3>

      <p>
        Используя <code>Subject</code>, мы можем не только получать изменения, подписавшись на них,
        но и транслировать их через <code>next()</code>.

        Если же говорить о <code>Observable</code>, то тут всё проще - они позволяют транслировать события только в момент инициализации.
        Таким образом, в коде мы можем использовать их ТОЛЬКО для получения изменений, используя метод <code>subscribe()</code>.
      </p>
    `,
    tags: ['TypeScript', 'Observables', 'Async', 'RxJs'],
    structure: [
      {
        name: 'Специфика Subject',
        isChecked: false,
      },
      {
        name: 'Различия поведения и виды Subject',
        isChecked: false,
      },
      {
        name: 'Специфика Observable',
        isChecked: false,
      },
      {
        name: 'Observable - только на получение данных, Subject - ещё и для распространения',
        isChecked: false,
      }
    ],
  },
  {
    id: 69,
    name: 'Zone.js. Что это и для чего нужно?',
    answer: ``,
    tags: ['TypeScript', 'TS mechanics', 'Async'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 70,
    name: 'Механизм Change Detection',
    answer: ``,
    tags: ['TypeScript', 'TS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 71,
    name: 'Lifecycle Angular (Жизненный цикл компонента)',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 72,
    name: 'Что такое Enums? Их применение',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 73,
    name: 'Class, Interface. Различия и применение',
    answer: ``,
    tags: ['TypeScript', 'Angular', 'ООП'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 74,
    name: 'Что такое Generics? Их применение',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 75,
    name: 'Что такое never в TypeScript?',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 76,
    name: 'Когда использовать .asObservable() в RxJs?',
    answer: `
      <p>
        Смысл использования <code>Subject.prototype.asObservable()</code> состоит в том, чтобы предотвратить
        утечку &quot;observer side&quot; из API (предотвратить утечку абстракции, когда вы не хотите,
        чтобы кто-либо мог вызвать метод <code>next()</code> у возвращаемого значения).
      </p>
      <code class="code">
        const myAPI = {
          getData: () =&gt; {
            const subject = new Subject();
            const source = new SomeWeirdDataSource();
            source.onMessage = (data) =&gt; subject.next({ type: &#39;message&#39;, data });
            source.onOtherMessage = (data) =&gt; subject.next({ type: &#39;othermessage&#39;, data });
            return subject.asObservable();
          }
        };
      </code>

      <p>Теперь, когда кто-то получит результат от <code>myAPI.getData()</code> , он не может вызвать метод next():</p>

      <code class="code">
        const result = myAPI.getData();
        result.next(&#39;LOL hax!&#39;); // throws an error because next doesn&#39;t exist
      </code>

      <p>
        В целом, это хорошая практика - инкапсулировать логику по управлению потоками данных внутри сервисов и не давать
        возможности менять эти данные извне без особой необходимости.
      </p>

      <p>
        Однако, в этом подходе также есть пара моментов, которые стоит учитывать. Во-первых,
        <code>getData()</code>
        не ленив, как большинство наблюдаемых, он немедленно создаст базовый источник данных
        <code>SomeWeirdDataSource</code>
        (и, предположительно, некоторые побочные эффекты).
        Во-вторых, на выходе <code>getData()</code> возвращает <code>return subject.asObservable();</code>,
        которое каждый раз будет новым наблюдаемым.;
      </p>

      <p>
        Таким образом, использовать этот подход следует с осторожностью.
        Также следует вынести часть с созданием <code>new Subject</code> за пределы этой функции,
        дабы не создавать новую сущность при каждом вызове (например, производить инициализацию
        <code>Subject</code> в корне компонента).
      </p>
    `,
    tags: ['TypeScript', 'Angular', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 77,
    name: 'Основные принципы ООП',
    answer: ``,
    tags: ['programming', 'ООП'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 78,
    name: 'Паттерны проектирования',
    answer: ``,
    tags: ['Patterns', 'best-practice'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 79,
    name: 'Декораторы функций. Что это такое и для чего?',
    answer: `
      <p class="info info--blue">
        Декоратор — это структурный паттерн проектирования.
      </p>

      <h3>Что такое декоратор?</h3>
      <p>
        <span class="accent">Декоратор</span> — это функция-обёртка (wrapper), которая принимает другую функцию и
        расширяет или изменяет её поведение, не вмешиваясь в её исходный код.
      </p>

      <p>
        <strong>Зачем нужен</strong>: Позволяет разделить основную бизнес-логику и вспомогательный
        функционал (например, кэширование, логирование, проверки типов).
      </p>

      <h3>Пример использования</h3>

      <p>
        Допустим, у нас есть функция <code>slow(x)</code>, которая выполняет ресурсоёмкие вычисления. Мы хотим оптимизировать её,
        добавив кэширование результатов, чтобы при повторных вызовах с теми же аргументами она возвращала результат из кэша.
      </p>

      <code class="code">
        function slow(x) {
          // здесь могут быть ресурсоёмкие вычисления
          alert(\`Called with \${x}\`);
          return x;
        }

        function cachingDecorator(func) {
          let cache = new Map();

          return function(x) {
            if (cache.has(x)) {    // если кеш содержит такой x,
              return cache.get(x); // читаем из него результат
            }

            let result = func(x); // иначе, вызываем функцию

            cache.set(x, result); // и кешируем (запоминаем) результат
            return result;
          };
        }

        slow = cachingDecorator(slow);

        alert( slow(1) ); // slow(1) кешируем
        alert( "Again: " + slow(1) ); // возвращаем из кеша

        alert( slow(2) ); // slow(2) кешируем
        alert( "Again: " + slow(2) ); // возвращаем из кеша
      </code>
    `,
    tags: ['JavaScript', 'Patterns', 'best-practice'],
    structure: [
      {
        name: 'Декоратор',
        isChecked: false,
      }
    ],
  },
  {
    id: 80,
    name: 'SOLID. Что это такое и зачем?',
    answer: ``,
    tags: ['programming', 'best-practice', 'ООП'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 81,
    name: 'Протокол HTTP. Что это такое и с чем его едят?',
    answer: ``,
    tags: ['protocol', 'internet'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 82,
    name: 'Специальные селекторы. Псевдоклассы :host, :host-context и псевдоэлемент ::ng-deep',
    answer: `
      <p>
        Стили компонентов имеют несколько специальных селекторов из мира shadow DOM
        (описаны на странице <code>CSS Scoping Module Level 1</code> на сайте W3C).
        Давайте познакомимся с этими селекторами поближе.
      </p>

      <h3>:host</h3>
      <p>
        Каждый компонент связан с элементом в верстке, который носит его имя-селектор.
        Этот элемент называется хост-элементом, в него рендерится шаблон.
        Селектор псевдокласса <code>:host</code> может использоваться чтобы создавать стили
        для самого элемента хоста, а не элементов внутри него.
      </p>
      <p>
        Стили, описанные в <code>:host</code> будут нацелены на основной элемент компонента.
        Любое правило, примененное к этому селектору псевдокласса, повлияет на основной элемент и все
        его потомки.
      </p>
      <p>
        Селектор псевдокласса <code>:host</code> нацелен только на хост-элемент компонента.
        Любые стили в блоке <code>:host</code> дочернего компонента не повлияют на родительские компоненты.
      </p>
      <p>
        Используйте форму функции для условного применения стилей хоста, включив другой селектор в круглые скобки после <code>:host</code>.
      </p>
      <code class="code">
        :host {
          font-style: italic;
        }

        :host(.active) {
          font-weight: bold;
        }
      </code>
      <p>
        Селектор псевдокласса <code>:host</code> можно комбинировать с другими селекторами.
      </p>

      <h3>:host-context</h3>
      <p>
        Иногда полезно применять стили к элементам в шаблоне компонента
        на основе некоторого условия в элементе-предке основного элемента.
        Например, класс цветовой темы CSS может быть применен к элементу документа <code>< body ></code>,
        и вы хотите изменить внешний вид вашего компонента на основе этого.
      </p>
      <p>
        Селектор псевдокласса <code>:host-context()</code> работает так же, как
        функциональная форма <code>:host()</code>. Селектор <code>:host-context()</code> ищет класс CSS в
        любом предке хост-элемента компонента, вплоть до корня документа.
      </p>
      <code class="code">
        :host-context(.active) {
          font-style: italic;
        }
      </code>
      <p>
        Обратите внимание, что будут затронуты только основной элемент и его потомки, а не предок с назначенным активным классом.
      </p>

      <h3>(deprecated) /deep/, >>>, and ::ng-deep</h3>
      <p>
        Стили компонентов обычно применяются только к HTML в собственном шаблоне компонента.
      </p>
      <p>
        Применение псевдокласса <code>::ng-deep</code> к любому правилу CSS полностью отключает инкапсуляцию
        представления для этого правила. При этом стиль становится глобальным стилем.
        Чтобы применить указанный стиль к текущему компоненту и всем его потомкам,
        обязательно включите селектор <code>:host</code> перед <code>::ng-deep</code>.
        Если псевдокласса <code>::ng-deep</code> используется без селектора псевдокласса <code>:host</code>,
        стиль может просачиваться в другие компоненты.
      </p>
      <p>
        Следующий пример предназначен для всех элементов <code>< h3 ></code>, начиная с основного
        элемента и вниз по дереву его дочерних DOM-элементов.
      </p>
      <code class="code">
        :host ::ng-deep h3 {
          font-style: italic;
        }
      </code>
      <p>
        Псевдокласса <code>/deep/</code> также имеет псевдонимы <code>>>></code> и <code>::ng-deep</code>.
      </p>
      <p class="info info--orange">
        Селектор псевдокласса потомков <code>::ng-deep</code> устарел, и его поддержка прекращается в основных браузерах и инструментах.
        Таким образом, мы планируем отказаться от поддержки в Angular
        (для всех 3 псевдоклассов: <code>/deep/</code>, <code>>>></code> и <code>::ng-deep</code>).<br>
        До тех пор следует отдавать предпочтение <code>::ng-deep</code> для более широкой совместимости с инструментами.
      </p>
    `,
    tags: ['Angular', 'html', 'markup'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 83,
    name: 'SQL. Основные команды',
    answer: `
      <h3>Структура sql-запросов</h3>

      <p>Общая структура запроса выглядит следующим образом:</p>
      <code class="code">
        SELECT ('столбцы или * для выбора всех столбцов; обязательно')
        FROM ('таблица; обязательно')
        WHERE ('условие/фильтрация, например, city = 'Moscow'; необязательно')
        GROUP BY ('столбец, по которому хотим сгруппировать данные; необязательно')
        HAVING ('условие/фильтрация на уровне сгруппированных данных; необязательно')
        ORDER BY ('столбец, по которому хотим отсортировать вывод; необязательно')
      </code>
      </br>

      <h3>Команды SQL, которые должен знать каждый программист:</h3>

      <code>
        SELECT, FROM
      </code>
      <p>
        SELECT, FROM — обязательные элементы запроса, которые определяют выбранные столбцы, их порядок и источник данных.
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>;
      </code>
      <p>
        Выбрать все (обозначается как *) из таблицы Customers:
      </p>
      <code class="code">
        SELECT * FROM Customers
      </code>
      </br>

      <code>
        SELECT DISTINCT
      </code>
      <p>
        В столбцах таблицы могут содержаться повторяющиеся данные. Используйте SELECT DISTINCT для получения только неповторяющихся данных.
      </p>
      <code class="code">
        SELECT DISTINCT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>;
      </code>
      </br>

      <code>
        WHERE
      </code>
      <p>
        WHERE — необязательный элемент запроса, который используется, когда нужно отфильтровать данные по нужному условию.
        Очень часто внутри элемента where используются IN / NOT IN для фильтрации столбца по нескольким значениям,
        AND / OR для фильтрации таблицы по нескольким столбцам.
        </br>
        Можно использовать ключевое слово WHERE в SELECT для указания условий в запросе:
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;condition>;
      </code>
      <p>
        В запросе можно задавать следующие условия:
      </p>
      <ul>
        <li>сравнение текста;</li>
        <li>сравнение численных значений;</li>
        <li>логические операции AND (и), OR (или) и NOT (отрицание).</li>
      </ul>

      <p>
        Фильтрация по одному условию и одному значению:
      </p>
      <code class="code">
        SELECT * FROM Customers
          WHERE City = 'London'
      </code>
      <p>
        Фильтрация по одному условию и нескольким значениям с применением IN (включение) или NOT IN (исключение):
      </p>
      <code class="code">
        SELECT * FROM Customers
          WHERE City IN ('London', 'Berlin')
      </code>
      </br>
      <code class="code">
        SELECT * FROM Customers
          WHERE City NOT IN ('Madrid', 'Berlin','Bern')
      </code>

      <p>
        Фильтрация по нескольким условиям с применением AND (выполняются все условия)
        или OR (выполняется хотя бы одно условие) и нескольким значениям:
      </p>
      <code class="code">
        SELECT * FROM Customers
          WHERE Country = 'Germany' AND City NOT IN ('Berlin', 'Aachen') AND CustomerID > 15
      </code>
      </br>
      <code class="code">
        SELECT * FROM Customers
          WHERE City IN ('London', 'Berlin') OR CustomerID > 4
      </code>
      </br>

      <code>
        GROUP BY
      </code>
      <p>
        GROUP BY — необязательный элемент запроса, с помощью которого можно задать агрегацию по нужному столбцу
        (например, если нужно узнать какое количество клиентов живет в каждом из городов).
      </p>
      <p>
        При использовании GROUP BY обязательно:
      </p>

      <ol>
        <li>
          перечень столбцов, по которым делается разрез, был одинаковым внутри SELECT и внутри GROUP BY;
        </li>
        <li>
          агрегатные функции (SUM, AVG, COUNT, MAX, MIN) должны быть также указаны внутри SELECT с указанием столбца,
          к которому такая функция применяется.
        </li>
      </ol>

      <p>
        Группировка количества клиентов по городу:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) FROM Customers
          GROUP BY City
      </code>

      <p>
        Группировка количества клиентов по стране и городу:
      </p>
      <code class="code">
        SELECT Country, City, COUNT(CustomerID) FROM Customers
          GROUP BY Country, City
      </code>

      <p>
        Группировка продаж по ID товара с разными агрегатными функциями:
        количество заказов с данным товаром и количество проданных штук товара:
      </p>
      <code class="code">
        SELECT ProductID, COUNT(OrderID), SUM(Quantity) FROM OrderDetails
          GROUP BY ProductID
      </code>

      <p>
        Группировка продаж с фильтрацией исходной таблицы.
        В данном случае на выходе будет таблица с количеством клиентов по городам Германии:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) FROM Customers
          WHERE Country = 'Germany'
          GROUP BY City
      </code>

      <p>
        Переименование столбца с агрегацией с помощью оператора AS.
        По умолчанию название столбца с агрегацией равно примененной агрегатной функции,
        что далее может быть не очень удобно для восприятия.
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) AS Number_of_clients FROM Customers
          GROUP BY City
      </code>
      </br>

      <code>
        HAVING
      </code>
      <p>
        HAVING — необязательный элемент запроса, который отвечает за фильтрацию на уровне сгруппированных данных
        (по сути, WHERE, но только на уровень выше).
      </p>
      <p>
        Ключевое слово HAVING было добавлено в SQL по той причине, что WHERE не может использоваться для работы с агрегатными функциями.
      </p>

      <p>
        Фильтрация агрегированной таблицы с количеством клиентов по городам,
        в данном случае оставляем в выгрузке только те города, в которых не менее 5 клиентов:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) FROM Customers
          GROUP BY City
          HAVING COUNT(CustomerID) >= 5
      </code>

      <p>
        В случае с переименованным столбцом внутри HAVING можно указать как и саму агрегирующую конструкцию
        count(CustomerID), так и новое название столбца number_of_clients:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) AS number_of_clients FROM Customers
          GROUP BY City
          HAVING number_of_clients >= 5
      </code>

      <p>
        Пример запроса, содержащего WHERE и HAVING.
        В данном запросе сначала фильтруется исходная таблица по пользователям,
        рассчитывается количество клиентов по городам и остаются только те города, где количество клиентов не менее 5:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) AS number_of_clients FROM Customers
          WHERE CustomerName NOT IN ('Around the Horn','Drachenblut Delikatessend')
          GROUP BY City
          HAVING number_of_clients >= 5
      </code>
      </br>

      <code>
        ORDER BY
      </code>
      <p>
        ORDER BY используется для сортировки результатов запроса по убыванию или возрастанию.
        ORDER BY отсортирует по возрастанию, если не будет указан способ сортировки ASC или DESC.
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          ORDER BY &lt;col_name1>, &lt;col_name2>, … ASC|DESC;
      </code>

      <p>
        Простой пример сортировки по одному столбцу. В данном запросе осуществляется сортировка по городу, который указал клиент:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY City
      </code>

      <p>
        Осуществлять сортировку можно и по нескольким столбцам, в этом случае сортировка происходит по порядку указанных столбцов:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY Country, City
      </code>

      <p>
        По умолчанию сортировка происходит по возрастанию для чисел и в алфавитном порядке для текстовых значений.
        Если нужна обратная сортировка, то в конструкции ORDER BY после названия столбца надо добавить DESC:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY CustomerID DESC
      </code>

      <p>
        Обратная сортировка по одному столбцу и сортировка по умолчанию по второму:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY Country DESC, City
      </code>
      </br>

      <code>
        BETWEEN
      </code>
      <p>
        BETWEEN используется для выбора значений данных из определённого промежутка.
        Могут быть использованы числовые и текстовые значения, а также даты.
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;col_namex> BETWEEN &lt;value1> AND &lt;value2>;
      </code>
      </br>

      <code>
        LIKE
      </code>
      <p>
        Оператор LIKE используется в WHERE, чтобы задать шаблон поиска похожего значения.
      </p>
      <p>
        Есть два свободных оператора, которые используются в LIKE:
      </p>

      <ul>
        <li>% (ни одного, один или несколько символов);</li>
        <li>_ (один символ).</li>
      </ul>

      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;col_namex> LIKE &lt;pattern>;
      </code>
      </br>

      <code>
        IN
      </code>
      <p>
        С помощью IN можно указать несколько значений для оператора WHERE:
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;col_namen> IN (&lt;value1>, &lt;value2>, …);
      </code>
      </br>

      <code>
        JOIN
      </code>
      <p>
        JOIN — необязательный элемент, используется для объединения таблиц (двух и более) по ключу, который присутствует в обеих таблицах.
        Перед ключом ставится оператор ON.
      </p>

      <p>
        Запрос, в котором соединяем таблицы Order и Customer по ключу CustomerID,
        при этом перед названиям столбца ключа добавляется название таблицы через точку:
      </p>
      <code class="code">
        SELECT * FROM Orders
          JOIN Customers ON Orders.CustomerID = Customers.CustomerID
      </code>

      <p>
        Нередко может возникать ситуация, когда надо промэппить одну таблицу значениями из другой.
        В зависимости от задачи, могут использоваться разные типы присоединений.
        INNER JOIN — пересечение, RIGHT/LEFT JOIN для мэппинга одной таблицы знаениями из другой.
      </p>

      <p>
        Внутри всего запроса JOIN встраивается после элемента FROM до элемента WHERE, пример запроса:
      </p>
      <code class="code">
        SELECT * FROM Orders
          JOIN Customers ON Orders.CustomerID = Customers.CustomerID
          WHERE Customers.CustomerID >10
      </code>

      <p>
        Другие типы JOIN'ов можно увидеть на замечательной картинке ниже:
      </p>
      <img src="../assets/img/join.png">

      <p>
        Более подробно про JOIN можно прочитать в прикрепленном материале (см. Источник 2).
      </p>

      <code>
        VIEW
      </code>
      <p>
        VIEW — это виртуальная таблица SQL, созданная в результате выполнения выражения.
        Она содержит строки и столбцы и очень похожа на обычную SQL-таблицу. VIEW всегда показывает самую свежую информацию из базы данных.
      </p>

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://habr.com/ru/post/480838/">Источник 1 (основоной)</a>
        </li>
        <li>
          <a href="https://function-x.ru/sql_join.html">Источник 2 (про JOIN и его разновидности)</a>
        </li>
        <li>
          <a href="https://tproger.ru/translations/sql-recap/">Источник 3 (очень краткий конспект с перечнем функций)</a>
        </li>
      </ul>
    `,
    tags: ['СУБД (системы управления базами данных)', 'databases', 'SQL'],
    structure: [
      {
        name: 'SELECT, FROM',
        isChecked: false,
      },
      {
        name: 'SELECT DISTINCT',
        isChecked: false,
      },
      {
        name: 'WHERE',
        isChecked: false,
      },
      {
        name: 'GROUP BY',
        isChecked: false,
      },
      {
        name: 'HAVING',
        isChecked: false,
      },
      {
        name: 'ORDER BY',
        isChecked: false,
      },
      {
        name: 'JOIN и его варианты',
        isChecked: false,
      }
    ],
  },
  {
    id: 84,
    name: 'Формат JSON, метод toJSON',
    answer: `
      <h3>
        JSON.stringify
      </h3>

      <p>
        <span class="accent">JSON</span> (JavaScript Object Notation) – это общий формат для представления значений и объектов.
        Его описание задокументировано в стандарте RFC 4627 (ещё 2006 год). Первоначально он был создан для JavaScript,
        но многие другие языки также имеют библиотеки, которые могут работать с ним. Таким образом,
        JSON легко использовать для обмена данными, когда клиент использует JavaScript, а сервер написан на Ruby/PHP/Java
        или любом другом языке.
      </p>

      <p>JavaScript предоставляет методы:</p>
      <ul>
        <li><code>JSON.stringify</code> - для преобразования объектов в JSON.</li>
        <li><code>JSON.parse</code> - для преобразования JSON обратно в объект.</li>
      </ul>

      <p class="info info--blue">
        Полученная из метода <code>JSON.stringify</code> строка называется JSON-форматированным или
        <span class="accent">сериализованным объектом</span>.
        Мы можем отправить его по сети или поместить в обычное хранилище данных.
        </br>
        Соответственно, из метода <code>JSON.parse</code> - <span class="accent">десериализованным объектом</span>.
      </p>

      <p>Обратите внимание, что объект в формате JSON имеет несколько важных отличий от объектного литерала:</p>
      <ul>
        <li>
          Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON.
          Так <code>'John'</code> становится <code>"John"</code>.
        </li>
        <li>
          Имена свойств объекта также заключаются в двойные кавычки. Это обязательно.
          Так <code>age:30</code> становится <code>"age":30</code>.
        </li>
        <li>
          Не допускаются комментарии.
        </li>
      </ul>

      <p><code>JSON.stringify</code> может быть применён и к примитивам.</p>
      <p>JSON поддерживает следующие типы данных:</p>

      <ul>
        <li>Объекты <code>{ ... }</code></li>
        <li>Массивы <code>[ ... ]</code></li>
        <li>Примитивы:
        <ul>
          <li>строки,</li>
          <li>числа,</li>
          <li>логические значения <code>true/false</code>,</li>
          <li><code>null</code>.</li>
        </ul>
        </li>
      </ul>

      <code class="code">
        // число в JSON остаётся числом
        alert( JSON.stringify(1) ) // 1

        // строка в JSON по-прежнему остаётся строкой, но в двойных кавычках
        alert( JSON.stringify('test') ) // "test"

        alert( JSON.stringify(true) ); // true

        alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
      </code>

      <p>
        Самое замечательное, что вложенные объекты поддерживаются и конвертируются автоматически.
      </p>

      <p>
        JSON является независимой от языка спецификацией для данных, поэтому <code>JSON.stringify</code>
        пропускает некоторые специфические свойства объектов JavaScript.
      </p>
      <p>А именно:</p>

      <ul>
        <li>Свойства-функции (методы).</li>
        <li>Символьные свойства.</li>
        <li>Свойства, содержащие <code>undefined</code>.</li>
      </ul>

      <code class="code">
        let user = {
          sayHi() { // будет пропущено
            alert("Hello");
          },
          [Symbol("id")]: 123, // также будет пропущено
          something: undefined // как и это - пропущено
        };

        alert( JSON.stringify(user) ); // {} (пустой объект)
      </code>

      <p class="info info--blue">
        Важное ограничение: не должно быть циклических ссылок.
      </p>

      <code class="code">
        let room = {
          number: 23
        };

        let meetup = {
          title: "Conference",
          participants: ["john", "ann"]
        };

        meetup.place = room;       // meetup ссылается на room
        room.occupiedBy = meetup; // room ссылается на meetup

        JSON.stringify(meetup); // Ошибка: Преобразование цикличной структуры в JSON
      </code>

      <p>
        Здесь преобразование завершается неудачно из-за циклической ссылки:
        room.occupiedBy ссылается на meetup, и meetup.place ссылается на room.
      </p>

      <h3>
        Исключаем и преобразуем: replacer
      </h3>

      <p>
        Полный синтаксис <code>JSON.stringify</code>:
      </p>
      <code class="code">
        let json = JSON.stringify(value[, replacer, space]);
      </code>
      <ul>
        <li><strong>value</strong> - значение для кодирования</li>
        <li>
          <strong>replacer</strong> - массив свойств <code>([key, key...])</code> для кодирования
          или функция соответствия <code>function(key, value)</code>
        </li>
        <li><strong>space</strong> - Дополнительное пространство (отступы), используемое для форматирования</li>
      </ul>

      <p>
        В большинстве случаев <code>JSON.stringify</code> используется только с первым аргументом.
        Но если нам нужно настроить процесс замены, например, отфильтровать циклические ссылки,
        то можно использовать второй аргумент <code>JSON.stringify</code>.
        </br>
        Если мы передадим ему массив свойств, будут закодированы только эти свойства.
      </p>

      <code class="code">
        let room = {
          number: 23
        };

        let meetup = {
          title: "Conference",
          participants: [{name: "John"}, {name: "Alice"}],
          place: room // meetup ссылается на room
        };

        room.occupiedBy = meetup; // room ссылается на meetup

        alert( JSON.stringify(meetup, ['title', 'participants']) );
        // {"title":"Conference","participants":[{},{}]}
      </code>
      <p>
        Здесь мы, наверное, слишком строги. Список свойств применяется ко всей структуре объекта.
        Так что внутри participants – пустые объекты, потому что name нет в списке.
      </p>

      <p>
        Если мы хотим, чтобы больше свойств было сериализовано, но не хотим указывать все имена свойств через запятую,
        можем использовать функцию-replacer.
        </br>
        В качестве replacer мы можем использовать функцию, а не массив.
        Функция будет вызываться для каждой пары (key, value), и она должна возвращать заменённое значение,
        которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение.
        (для более подробной информации см. Источник)
      </p>
      <code class="code">
        JSON.stringify(myObject, function replacer(key, value) {
          return (key == 'keyNameToSkip') ? undefined : value;
        })
      </code>

      <h3>
        Форматирование: space
      </h3>
      <p>
        Третий аргумент в <code>JSON.stringify(value, replacer, space)</code> - это количество пробелов,
        используемых для удобного форматирования.
      </p>

      <p>
        Ранее все JSON-форматированные объекты не имели отступов и лишних пробелов.
        Это нормально, если мы хотим отправить объект по сети. Аргумент <code>space</code>
        используется исключительно для вывода в удобочитаемом виде.
      </p>

      <h3>
        Пользовательский «toJSON»
      </h3>
      <p>
        Как и <code>toString</code> для преобразования строк, объект может предоставлять метод <code>toJSON</code>
        для преобразования в JSON. <code>JSON.stringify</code> автоматически вызывает его, если он есть.
      </p>

      <p>
        Например, добавим собственную реализацию метода <code>toJSON</code> в наш объект room:
      </p>
      <code class="code">
        let room = {
          number: 23,
          toJSON() {
            return this.number;
          }
        };

        let meetup = {
          title: "Conference",
          room
        };

        alert( JSON.stringify(room) ); // 23

        alert( JSON.stringify(meetup) );
        /*
          {
            "title":"Conference",
            "room": 23
          }
        */
      </code>
      <p>
        Как видите, <code>toJSON</code> используется как при прямом вызове <code>JSON.stringify(room)</code>,
        так и когда room вложен в другой сериализуемый объект.
      </p>

      <h3>
        JSON.parse
      </h3>

      <p>
        Чтобы декодировать JSON-строку, нам нужен другой метод с именем <code>JSON.parse</code>.
      </p>
      <code class="code">
        let value = JSON.parse(str, [reviver]);
      </code>
      <ul>
        <li><strong>str</strong> - JSON для преобразования в объект</li>
        <li>
          <strong>reviver</strong> - необязательная функция, которая будет вызываться для каждой пары
          (ключ, значение) и может преобразовывать значение
        </li>
      </ul>

      <h3>
        Использование reviver
      </h3>

      <p>
        Представьте, что мы получили объект meetup с сервера в виде строки данных.
      </p>
      <code class="code">
        // title: (meetup title), date: (meetup date)
        let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
      </code>

      <p>
        А теперь десериализуем её, т.е. снова превратим в объект JavaScript и попробуем обратиться к объекту Date.
      </p>
      <code class="code">
        let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
        let meetup = JSON.parse(str);

        alert( meetup.date.getDate() ); // Error!
      </code>
      <p>
        Ой, ошибка!

        Значением meetup.date является строка, а не Date объект. Как <code>JSON.parse</code> мог знать,
        что он должен был преобразовать эту строку в Date?
      </p>

      <p>
        Давайте передадим <code>JSON.parse</code> функцию восстановления вторым аргументом,
        которая возвращает все значения «как есть», но date станет Date:
      </p>
      <code class="code">
        let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

        let meetup = JSON.parse(str, function(key, value) {
          if (key == 'date') return new Date(value);
          return value;
        });

        alert( meetup.date.getDate() ); // 30 - теперь работает!
      </code>
      <p>
        Кстати, это работает и для вложенных объектов, в которых бедет ключ date!
      </p>

      <h3>
        Источники:
      </h3>
      <ul>
        <li>
          <a href="https://learn.javascript.ru/json">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['JSON', 'Data Structures'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 85,
    name: 'Аутентификация и авторизация. В чем разница?',
    answer: `
      <span class="accent">Аутентификация</span> (authentication) — это процесс проверки личности пользователя. Она отвечает на вопрос: "Кто ты?" Обычно это достигается с помощью логина и пароля, биометрических данных или других методов идентификации.
      </br>
      </br>
      <span class="accent">Авторизация</span> (authorization) — это процесс определения прав и разрешений пользователя после его аутентификации. Она отвечает на вопрос: "Что ты можешь делать?" Авторизация определяет, какие ресурсы и действия доступны пользователю в системе.

      <p>Важно понимать, что аутентификация и авторизация — это два разных процесса, которые часто идут рука об руку, но выполняют разные функции. Аутентификация подтверждает личность пользователя, а авторизация определяет его права доступа.</p>
      <p>Например, когда тебе приходит сообщение от друга занять деньги, ты сначала проверяешь, действительно ли это твой друг (аутентификация), а затем решаешь, позволить ли ему занять деньги (авторизация).</p>
    `,
    tags: ['security', 'authentication', 'authorization'],
    structure: [
      {
        name: 'Аутентификация',
        isChecked: false,
      },
      {
        name: 'Авторизация',
        isChecked: false,
      }
    ],
  },
  {
    id: 86,
    name: 'Безопасность приложений (AppSec)',
    answer: `<p>Для фронтенд-разработчика это критически важная зона. Сюда входит знание основных уязвимостей, таких как OWASP Top 10:</p>

    <p>XSS (Cross-Site Scripting): Внедрение вредоносного скрипта на страницу.</p>

    <p>CSRF (Cross-Site Request Forgery): Подделка межсайтовых запросов.</p>

    <p>SQL Injection: Манипуляция базой данных через незащищенные поля ввода.</p>`,
    tags: ['security', 'AppSec', 'OWASP'],
    structure: [
      {
        name: 'XSS',
        isChecked: false,
      },
      {
        name: 'CSRF',
        isChecked: false,
      },
      {
        name: 'SQL Injection',
        isChecked: false,
      }
    ],
  },
  {
    id: 87,
    name: 'Деревья, графы, перевернутые деревья',
    answer: `
      <p>
        <span class="accent">Дерево</span> — это структура данных, которая состоит из узлов, где каждый узел может иметь
        несколько дочерних узлов, но только одного родителя.
        </br>
        Деревья используются для представления иерархий, таких как файловая система или
        организация компании.
      </p>

      <p>
        <span class="accent">Граф</span> — это более общая структура данных, которая состоит из узлов (вершин) и рёбер,
        соединяющих эти узлы.
        </br>
        Графы могут быть направленными или ненаправленными, взвешенными или невзвешенными, и они используются для
        моделирования различных типов связей и сетей, таких как социальные сети, транспортные маршруты и компьютерные сети.
      </p>

      <p>
        <span class="accent">Перевернутое дерево</span> — это структура данных, которая похожа на дерево, но с обратными
        отношениями между узлами.
        </br>
        В перевернутом дереве каждый узел может иметь несколько родителей, но только одного ребенка. Это может быть
        полезно для представления зависимостей или обратных иерархий, таких как система управления задачами,
        где задачи могут зависеть от нескольких других задач.
      </p>
    `,
    tags: ['data structures', 'trees', 'graphs'],
    structure: [
      {
        name: 'Деревья',
        isChecked: false,
      },
      {
        name: 'Графы',
        isChecked: false,
      },
      {
        name: 'Перевернутые деревья',
        isChecked: false,
      }
    ],
  },
];
