import { Question } from 'src/app/models/question.model';

export const questions: Question[] = [
  {
    id: 1,
    name: 'Как браузер парсит страницу?',
    answer: `
      <p>Процесс отображения страниц браузером можно разбить на следующие основные этапы:</p>

      <ol>
        <li>Парсинг HTML, построение DOM</li>
        <li>Получение внешних ресурсов</li>
        <li>Разбор CSS и создание CSSOM</li>
        <li>Выполнение JavaScript</li>
        <li>Объединение DOM и CSSOM, для построения дерево рендеринга</li>
        <li>Расчет макета и отрисовка результата</li>
      </ol>

      <h3>
        1. Парсинг HTML, построение DOM
      </h3>

      <p>
        Когда браузер начинает получать данные HTML страницы по сети, он немедленно запускает
        свой синтаксический анализатор parser для преобразования HTML в объектную модель документа (DOM).
      </p>

      <p class="info info--blue">
        Объектная модель документа (DOM) — это представление данных объектов,
        которые составляют структуру и содержимое документа в Интернете.
      </p>

      <p>
        Первый шаг этого процесса синтаксического анализа — разбить HTML на токены, которые представляют начальные
        теги (start tags), конечные теги (end tags) и их содержимое (contents). Из этого он строит DOM.
      </p>

      <img src="../assets/img/step-1.png">

      <h3>
        2. Получение внешних ресурсов
      </h3>

      <p>
        Когда парсер встречает внешний ресурс, такой как файл CSS или JavaScript, он пытается получить его.
        Синтаксический анализатор будет продолжать работу по мере загрузки файла CSS, но он заблокирует
        рендеринг до тех пор, пока файл не будет загружен и проанализирован (подробнее об этом чуть позже).
      </p>

      <p>
        Файлы JavaScript немного отличаются — по умолчанию они так же блокируют синтаксический анализ HTML
        на время загрузки. Но у них есть два атрибута, которые могут быть добавлены в теги сценария, чтобы
        изменить это: <code>defer</code> и <code>async</code>. Оба позволяют синтаксическому анализатору продолжать работу, пока файл
        JavaScript загружается в фоновом режиме. Они отличаются друг от друга тем, как выполняются.
        Подробнее об этом тоже немного ниже, но вкратце:
      </p>

      <p>
        <code>defer</code> означает, что выполнение файла будет отложено до завершения синтаксического анализа документа.
        Если несколько файлов имеют атрибут <code>defer</code>, то они будут выполняться в том порядке, в котором они
        были обнаружены в HTML.
      </p>

      <code class="code">
        &lt;script type="text/javascript" src="script.js" defer>
      </code>

      <p>
        <code>async</code> означает, что файл будет выполнен, как только он загрузится, это может быть во время или после процесса
        синтаксического анализа, и поэтому порядок, в котором выполняются асинхронные сценарии, не может быть гарантирован.
      </p>

      <code class="code">
        &lt;script type="text/javascript" src="script.js" async>
      </code>

      <h3>
        Предварительная загрузка ресурсов
      </h3>

      <p>
        Кроме того, современные браузеры будут продолжать сканировать HTML-код, пока анализатор блокирован, и «смотреть вперед»
        на то, какие внешние ресурсы появляются, а затем загружать их предположительно. То, как они это делают, варьируется в
        зависимости от браузера, поэтому нельзя полагаться на то, что они будут вести себя определенным образом. Чтобы пометить
        ресурс как важный и, следовательно, с большей вероятностью он должен быть загруженным на ранней стадии процесса рендеринга,
        можно использовать тег ссылки с <code>rel = «preload»</code>.
      </p>

      <code class="code">
        &lt;link href="style.css" rel="preload" as="style" />
      </code>

      <img src="../assets/img/step-2.png">

      <h3>
        3. Разбор CSS и создание CSSOM
      </h3>

      <p>
        Возможно, вы слышали о DOM, но слышали ли вы о CSSOM (CSS Object Model) (объектной модели CSS)?
        До того, как я начал исследовать эту тему, я об этом ни чего не знал!
      </p>

      <p class="info info--blue">
        Объектная модель CSS (CSSOM) — это карта всех селекторов CSS и соответствующих свойств для каждого селектора
        в форме дерева с корневым узлом, родственником, потомком, дочерним элементом и другими отношениями.
        CSSOM очень похож на объектную модель документа (DOM). Оба они являются частью пути рендеринга,
        который представляет собой серию шагов, которые должны пройти для правильного рендеринга веб-сайта.
      </p>

      <p class="info info--blue">
        CSSOM вместе с DOM используется для построения дерева рендеринга,
        которое, в свою очередь, используется браузером для компоновки и раскраски веб-страницы.
      </p>

      <p>
        Подобно файлам HTML и DOM, когда файлы CSS загружаются, они должны быть проанализированы и
        преобразованы в дерево — на этот раз CSSOM. Он описывает все селекторы CSS на странице, их иерархию и их свойства.
      </p>

      <p>
        Чем CSSOM отличается от DOM, так это тем, что он не может быть построен постепенно, поскольку правила CSS могут
        перезаписывать друг друга в разных точках из-за specificity (порядка применения свойства).
        Вот почему загрузка CSS блокирует рендеринг, поскольку до тех пор, пока весь CSS не будет
        проанализирован и не будет построен CSSOM, браузер не может знать, где и как разместить каждый элемент на экране.
      </p>

      <img src="../assets/img/step-3.jpeg">

      <h3>
        4. Выполнение JavaScript
      </h3>

      <p>
        Как и когда ресурсы JavaScript будут загружены определяет то, в какой момент они будут проанализированы, скомпилированы
        и выполнены. В разных браузерах для выполнения этой задачи используются разные механизмы JavaScript.
        Анализ JavaScript может быть дорогостоящим процессом с точки зрения ресурсов компьютера,
        в большей степени, чем другие типы ресурсов, поэтому его оптимизация так важна для достижения хорошей производительности.
      </p>

      <h3>
        События загрузки
      </h3>

      <p>
        После того, как синхронно загруженный JavaScript и DOM будут полностью проанализированы и готовы, будет сгенерировано
        событие document.DOMContentLoaded. Для любых сценариев, которым требуется доступ к DOM, например, для
        управления им или прослушивания событий взаимодействия с пользователем, рекомендуется сначала дождаться этого
        события перед выполнением сценариев.
      </p>

      <code class="code">
        document.addEventListener('DOMContentLoaded', (event) => {
          // You can now safely access the DOM
        });
      </code>

      <p>
        После того, как все остальное, например асинхронный JavaScript, изображения и т. д.,
        завершили загрузку, запускается событие window.load.
      </p>

      <code class="code">
        window.addEventListener('load', (event) => {
          // The page has now fully loaded
        });
      </code>

      <br>

      <img src="../assets/img/step-4.png">

      <h3>
        5. Объединение DOM и CSSOM, построение дерева рендеринга
      </h3>

      <p>
        Дерево рендеринга представляет собой комбинацию DOM и CSSOM и представляет всё, что будет отображаться на странице.
        Это не обязательно означает, что все узлы в дереве рендеринга будут визуально присутствовать.
        <br>
        Например, узлы со стилями <code>opacity: 0</code> или <code>visibility: hidden</code> будут включены и
        могут быть прочитаны программой чтения с экрана и т. д. Тогда как те, которые имеют стиль <code>display: none</code>,
        будут исключены. Кроме того, теги вроде &lt;head>, не содержащие визуальной информации, всегда будут пропущены.
      </p>

      <p>
        Как и в случае с движками JavaScript, разные браузеры имеют разные механизмы рендеринга.
      </p>

      <img src="../assets/img/step-5.png">

      <h3>
        6. Расчет макета и отрисовка результата
      </h3>

      <p>
        Теперь, когда у нас есть полное дерево рендеринга, браузер знает, что рендерить, но не знает, где рендерить.
        Следовательно, необходимо рассчитать макет страницы (то есть положение и размер каждого узла).
        Механизм рендеринга проходит дерево рендеринга, начиная с вершины и идя вниз, вычисляет координаты, в
        которых должен отображаться каждый узел.
      </p>

      <p>
        Как только это будет сделано, последний шаг — используя эту информацию о макете, отрисовать пиксели на экране.
      </p>

      <p>
        И вуаля! В конце концов, у нас есть полностью отрисованная веб-страница!
      </p>

      <img src="../assets/img/step-6.png">

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://webdevblog.ru/kak-brauzer-renderit-veb-stranicu/">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['markup', 'browser'],
    structure: [
      {
        name: 'Парсинг HTML, построение DOM',
        isChecked: false,
      },
      {
        name: 'Получение внешних ресурсов (JS, CSS)',
        isChecked: false,
      },
      {
        name: 'Разбор CSS и создание CSSOM',
        isChecked: false,
      },
      {
        name: 'Выполнение JavaScript',
        isChecked: false,
      },
      {
        name: 'Объединение DOM и CSSOM для построения дерево рендеринга',
        isChecked: false,
      },
      {
        name: 'Расчет макета и отрисовка результата',
        isChecked: false,
      },
    ],
  },
  {
    id: 2,
    name: 'Что такое <DOCTYPE>. Зачем он нужен?',
    answer: `
      <h3>
        Что такое DOCTYPE?
      </h3>
      <p>
        <span class="accent">Тег &lt;!doctype></span>
        — DTD (document type definition, описание типа документа) указывает тип документа,
        который используется при написании html кода. Это непарный тег, который должен стоять самым первым в
        коде каждой страницы вашего сайта.
      </p>

      <p>
        Нужно понимать, что строчка, в которой прописывается <code>DOCTYPE</code> - это не просто очередной HTML тег.
        Это важная инструкция, с помощью которой мы говорим браузеру, какая версия HTML использовалась при написании страницы.
      </p>

      <p>
        Главным преимуществом использования <code>DOCTYPE</code> является то,
        что ваш сайт будет правильно работать и одинаково ровно и красиво смотреться во всех браузерах.
      </p>

      <h3>
        Зачем нужен DOCTYPE?
      </h3>

      <p>
        Тег <code>DOCTYPE</code> — ключевой компонент web-страниц, претендующих на соответствие стандартам:
        без него ваш код и CSS не пройдут проверку валидатором.
        Тег <code>DOCTYPE</code> также важен для правильного отображения и работы страницы в броузерах, соответствующих стандартам
        (Mozilla, IE5/Mac, и IE6/Win).
      </p>

      <h3>
        Какие существуют виды DOCTYPE?
      </h3>

      <p>
        Cуществует несколько видов <code>DOCTYPE</code>. Есть строгие виды (<strong>strict</strong>),
        которые работают на основе только определенных тегов, есть переходные (<strong>transitional</strong>),
        которые допускают возможность включения дополнительных тегов, есть такие, которые работают с фреймами
        (<strong>frameset</strong>).
      </p>

      <p>Подробно в этой статье я не буду рассматривать каждый из них, так как это не является моей целью, просто перечислю:</p>

      <ol>
        <li><strong>HTML 5</strong></li>
        <li><strong>HTML 4.01 Strict</strong></li>
        <li><strong>HTML 4.01 Transitional</strong></li>
        <li><strong>HTML 4.01 Frameset</strong></li>
        <li><strong>XHTML 1.0 Strict</strong></li>
        <li><strong>XHTML 1.0 Transitional</strong></li>
        <li><strong>XHTML 1.0 Frameset</strong></li>
        <li><strong>XHTML 1.1</strong></li>
      </ol>

      <p>
        Что касается использования разных видов <code>DOCTYPE</code>, следует иметь ввиду, что если вы изначально писали свой
        сайт в одном <code>DOCTYPE</code>, то не рекомендуется его менять в будущем на какой-то другой, потому что могут
        возникнуть проблемы с правильным отображением сайта из-за того, что вместе со сменой <code>DOCTYPE</code> вы
        автоматически поменяете правила обработки тегов браузерами.
      </p>

      <h3>
        Можно ли вообще обойтись без DOCTYPE?
      </h3>

      <p>
        Теоретически, <code>DOCTYPE</code> не является необходимым тегом, но если вы не используете <code>DOCTYPE</code>
        совсем, то рискуете лицезреть созданный вами сайт не в самом приглядном виде в браузере.
        Причем в каждом браузере будут возникать разные проблемы с правильностью отображения,
        а решить все их вам будет, мягко говоря, сложновато.
      </p>

      <h3>
        Преимущества использования DOCTYPE HTML5
      </h3>

      <p>
        Хорошая новость состоит в том, что с выходом последней версии HTML5 стало намного удобней выбирать DOCTYPE для своих сайтов.
      </p>

      <p>
        Дело в том, что правила <code>DOCTYPE</code> HTML5 являются универсальными, включают в себя правила предыдущей версии,
        а также возможность работы с HTML 4 тегами и, в какой-то степени, с XHTML.
        Насколько я понимаю, они объединяют в себе возможности всех своих предшественников, адаптируя их для работы в новых браузерах.
      </p>

      <p>
        Поэтому сейчас следует (практически) всегда использовать <code>DOCTYPE</code> HTML5,
        для чего просто следует добавить в начале страницы:
      </p>

      <code class="code">
        &lt;!DOCTYPE html>
      </code>

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://mega-css.com/page/doctype">Источник 1</a>
        </li>
        <li>
          <a href="https://habr.com/ru/post/71364/">Источник 2</a>
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup'],
    structure: [
      {
        name: 'Что такое этот тег DOCTYPE',
        isChecked: false,
      },
      {
        name: 'Зачем нужен DOCTYPE',
        isChecked: false,
      },
      {
        name: 'Рассказать, про то что есть разные виды DOCTYPE',
        isChecked: false,
      },
      {
        name: 'Можно ли вообще обойтись без DOCTYPE?',
        isChecked: false,
      },
      {
        name: 'Сейчас практически всегда стоит юзать DOCTYPE HTML5',
        isChecked: false,
      }
    ],
  },
  {
    id: 3,
    name: 'Теги HTML5. Семантика. Доступность.',
    answer: `
      <h3>
        Что такое семантическая вёрстка и зачем она нужна
      </h3>

      <p class="info info--blue">
        Давным-давно (лет 10-15 назад) почти все делали сайты и не переживали о том, что под капотом.
        Верстали таблицами, использовали всё, что попадётся под руку (а попадались в основном div и span) и
        не особо заморачивались о доступности.
        <br>
        <br>
        А потом случился HTML5 - и понеслось.
      </p>

      <p>
        <span class="accent">Семантическая вёрстка</span> — подход к разметке, который опирается не на содержание сайта,
        а на смысловое предназначение каждого блока и логическую структуру документа.
        Даже в этой статье есть заголовки разных уровней — это помогает читателю выстроить в голове структуру документа.
        Так и на странице сайта — только читатели будут немного другими.
      </p>

      <h3>
        Почему семантика важна
      </h3>

      <p>
        <strong>Чтобы сделать сайт доступным.</strong> Зрячие пользователи могут без проблем с первого взгляда понять,
        где какая часть страницы находится — где заголовок, списки или изображения. Для незрячих или частично незрячих
        всё сложнее. Основной инструмент для просмотра сайтов не браузер, который отрисовывает страницу, а скринридер,
        который читает текст со страницы вслух.
        <br>
        Этот инструмент «зачитывает» содержимое страницы, и семантическая структура помогает ему лучше определять,
        какой сейчас блок, а пользователю понимать, о чём идёт речь.
      </p>

      <p>
        <strong>Чтобы сайт был выше в поисковиках.</strong> Компании, которые создают поисковики, не разглашают правила ранжирования,
        но известно, что наличие семантической разметки страниц помогает поисковым ботам лучше понимать, что находится
        на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.
      </p>

      <p>
        Семантика прописана в стандартах. Многие разработчики по старинке пользуются конструкциями типа <code>&lt;div id="nav"></code>
        для обозначения навигации или других структурных элементов страницы. Тем временем в стандарте HTML есть несколько
        семантических тегов, которые рекомендуется использовать для разметки страниц вместо <code>&lt;div></code> и <code>&lt;span></code>.
        В спецификации для каждого семантического элемента описана его роль.
      </p>

      <p>
        Ну и представьте, насколько проще читать <code>&lt;nav>&lt;/nav></code> вместо <code>&lt;div class="nav">&lt;/div></code>.
        <br>
        Или вот такой код. Смотрите и сразу понятно, что тут и зачем:
      </p>

      <code class="code">
        &lt;!DOCTYPE html>
        &lt;html lang="ru">
          &lt;head>
            &lt;meta charset="utf-8">
            &lt;title>Заголовок страницы&lt;/title>
          &lt;/head>
          &lt;body>
            &lt;header class="main-header">
              &lt;!— Шапка сайта —>
            &lt;/header>
            &lt;main>
              &lt;!— Основное содержимое страницы —>
            &lt;/main>
            &lt;footer class="main-footer">
              &lt;!— Подвал сайта —>
            &lt;/footer>
          &lt;/body>
        &lt;/html>
      </code>

      <h3>
        Основные семантические теги HTML
      </h3>

      <p>
        Среди «старых» тегов из ранних версий HTML тоже есть семантические — например, тег <code>&lt;p></code>,
        который обозначает параграф. При этом теги <code>&lt;i></code> или <code>&lt;b></code> не семантические, потому что они
        не добавляют смысла выделенному тексту, а просто определяют его внешний вид.
      </p>

      <p>
        Но в актуальной версии стандарта HTML Living Standard есть семантические
        теги почти для всех основных частей сайта, и лучше пользоваться ими. Вот несколько примеров семантических тегов.
      </p>

      <h4>
        &lt;article>
      </h4>

      <p>
        <strong>Значение:</strong> независимая, отделяемая смысловая единица, например комментарий, твит, статья, виджет ВК и так далее.
      </p>

      <p>
        <strong>Особенности:</strong> желателен заголовок внутри.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> путают с тегами <code>&lt;section></code> и <code>&lt;div></code>.
      </p>

      <h4>
        &lt;section>
      </h4>

      <p>
        <strong>Значение:</strong> смысловой раздел документа. Неотделяемый, в отличие от <code>&lt;article></code>.
      </p>

      <p>
        <strong>Особенности:</strong> желателен заголовок внутри.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> путают с тегами <code>&lt;article></code> и <code>&lt;div></code>.
      </p>

      <h4>
        &lt;aside>
      </h4>

      <p>
        <strong>Значение:</strong> побочный, косвенный для страницы контент.
      </p>

      <p>
        <strong>Особенности:</strong> может иметь свой заголовок. Может встречаться несколько раз на странице.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> считать <code>&lt;aside></code> тегом для «боковой панели» и
        размечать этим тегом основной контент, который связан с окружающими его элементами.
      </p>

      <h4>
        &lt;nav>
      </h4>

      <p>
        <strong>Значение:</strong> навигационный раздел со ссылками на другие страницы или другие части страниц.
      </p>

      <p>
        <strong>Особенности:</strong> используется для основной навигации, а не для всех групп ссылок.
        Основной является навигация или нет — на усмотрение верстальщика.
        Например, меню в подвале сайта можно не оборачивать в <code>&lt;nav></code>. В подвале обычно появляется краткий
        список ссылок (например, ссылка на главную, копирайт и условия) — это не является основной навигацией,
        семантически для такой информации предназначен <code>&lt;footer></code> сам по себе.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> многие считают, что в <code>&lt;nav></code> может быть
        только список навигационных ссылок, но согласно спецификации там может быть навигация в любой форме.
      </p>

      <h4>
        &lt;header>
      </h4>

      <p>
        <strong>Значение:</strong> вводная часть смыслового раздела или всего сайта, обычно содержит
        подсказки и навигацию. Чаще всего повторяется на всех страницах сайта.
      </p>

      <p>
        <strong>Особенности:</strong> этих элементов может быть несколько на странице.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> использовать только как шапку сайта.
      </p>

      <h4>
        &lt;main>
      </h4>

      <p>
        <strong>Значение:</strong> основное, не повторяющееся на других страницах, содержание страницы.
      </p>

      <p>
        <strong>Особенности:</strong> должен быть один на странице, исходя из определения.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> включать в этот тег то, что повторяется на других страницах (навигацию, копирайты и так далее).
      </p>

      <h4>
        &lt;footer>
      </h4>

      <p>
        <strong>Значение:</strong> заключительная часть смыслового раздела или всего сайта, обычно содержит информацию об авторах,
        список литературы, копирайт и так далее. Чаще всего повторяется на всех страницах сайта.
      </p>

      <p>
        <strong>Особенности:</strong> этих элементов может быть несколько на странице. Тег <code>&lt;footer></code>
        не обязан находиться в конце раздела.
      </p>

      <p>
        <strong>Типовые ошибки:</strong> использовать только как подвал сайта.
      </p>

      <h3>
        Как разметить страницу с точки зрения семантики
      </h3>

      <p>
        Процесс разметки можно разделить на несколько шагов с разной степенью детализации.
      </p>

      <ol>
        <li>
          Крупные смысловые блоки на каждой странице сайта. Теги: <code>&lt;header&gt;, &lt;main&gt;, &lt;footer&gt;</code>.
        </li>
        <li>
          Крупные смысловые разделы в блоках. Теги: <code>&lt;nav&gt;, &lt;section&gt;, &lt;article&gt;, &lt;aside&gt;</code>.
        </li>
        <li>Заголовок всего документа и заголовки смысловых разделов. Теги: <code>&lt;h1&gt;-&lt;h6&gt;</code>.</li>
        <li>
          Мелкие элементы в смысловых разделах. Списки, таблицы, демо-материалы, параграфы и переносы,
          формы, цитаты, контактная информация и прогресс.
        </li>
        <li>Фразовые элементы. Изображения, ссылки, кнопки, видео, время и мелкие текстовые элементы.</li>
      </ol>

      <p>
        Более подробно методика создания семантической разметки описана в навыке
        <a href="https://htmlacademy.ru/skills/semantic-markup">
          Создание семантической разметки по макету
        </a>.
      </p>

      <h3>
        Сомневаюсь, какие теги использовать
      </h3>

      <p>Есть простые правила для выбора нужных тегов.</p>

      <ul>
        <li>Получилось найти самый подходящий смысловой тег - использовать его.</li>
        <li>Для потоковых контейнеров - <code>&lt;div&gt;</code>.</li>
        <li>Для мелких фразовых элементов (слово или фраза) - <code>&lt;span&gt;</code>.</li>
      </ul>

      <p>Правило для определения <code>&lt;article&gt;, &lt;section&gt;</code> и <code>&lt;div&gt;</code>:</p>

      <ol>
        <li>Можете дать имя разделу и вынести этот раздел на другой сайт? - <code>&lt;article&gt;</code></li>
        <li>Можете дать имя разделу, но вынести на другой сайт не можете? - <code>&lt;section&gt;</code></li>
        <li>
          Не можете дать имя? Получается что-то наподобие "новости и фотогалерея" или "правая колонка"? - <code>&lt;div&gt;</code>
        </li>
      </ol>


      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://htmlacademy.ru/blog/boost/frontend/semantics">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup'],
    structure: [
      {
        name: 'Что такое семантическая вёрстка и зачем она нужна',
        isChecked: false,
      },
      {
        name: 'Основные семантические теги HTML',
        isChecked: false,
      },
      {
        name: 'Как разметить страницу с точки зрения семантики',
        isChecked: false,
      },
    ],
  },
  {
    id: 4,
    name: 'Какие есть способы подключить CSS на страницу?',
    answer: `
      <p>
        Каскадные таблицы стилей CSS (Cascading Style Sheets) нужны для оформления страниц вашего сайта в соответствии с
        разработанным стилем, дизайном.
      </p>

      <p>
        Таблицы стилей CSS являются неотъемлемой частью страниц современного сайта. Рассмотрим как подключить CSS к HTML документу.
      </p>

      <p>
        Существует 5 основных способов подключения или добавления CSS стилей к HTML документу, каждый их которых
        подходит для определенного круга задач.
      </p>

      <h3>
        1. Подключение CSS через внешний файл стилей тегом link
      </h3>

      <p>
        Наиболее правильный вариант определения общих стилей для сайта - это подключение внешнего файла CSS с помощью тега &lt;link>.
      </p>

      <p>
        Чтобы подключить CSS файл, в head области страницы используйте следующую конструкцию:
      </p>

      <code class="code">
        &lt;link href="URL_адрес_CSS_файла" rel="stylesheet" type="text/css">
      </code>

      <p>
        В атрибуте href необходимо указать URL адрес файла, содержащего набор стилей CSS.
        Атрибуты <code>rel="stylesheet"</code> и <code>type="text/css"</code> указывают,
        что указанный файл является таблицей стиля в формате CSS.
      </p>

      <p>
        Вы можете привязать неограниченное количество файлов CSS к одной странице сайта.
        Однако подключение большого количества объемных CSS файлов приведет к увеличению веса страницы, и
        соответственно может привести к увеличению времени загрузки и обработки страницы.
      </p>

      <h3>
        2. Добавление CSS с помощью тега style
      </h3>

      <p>
        Этот метод подойдет когда нужно вставить (определить) стили для группы уникальных элементов страницы,
        то есть, набор стилей, которые используются только в пределах одной страницы и не нужны для корректной
        работы остальных страниц сайта.
      </p>

      <p>
        В любом месте областей <code>&lt;head></code>и <code>&lt;body></code> HTML документа используйте тег <code>&lt;style></code>,
        внутри которого поместите необходимые CSS правила.
      </p>

      <code class="code">
        &lt;style type="text/css">
          /* CSS код */
        &lt;/style>
      </code>

      <h3>
        3. Импорт CSS через команду @import
      </h3>

      <p>
        В текущую стилевую таблицу можно импортировать содержимое CSS-файла с помощью команды <code>@import</code>.
        Этот метод допускается использовать совместно со связанными или глобальными стилями, но никак не с внутренними стилями.
        Общий синтаксис следующий.
      </p>

      <code class="code">
        @import url("имя файла") типы носителей;
        @import "имя файла" типы носителей;
      </code>

      <h3>
        4. Inline-стили CSS
      </h3>

      <p>
        Если вам нужно задать стиль для конкретного элемента контента страницы (одного конкретного тега),
        воспользуйтесь атрибутом <code>style</code>.
      </p>

      <code class="code">
        &lt;p style="CSS_код">текст&lt;/p>
      </code>

      <p>
        Стили, заданные через атрибут <code>style</code> называют inline-стилями.
        Такие стили имеют приоритет перед стилями, заданными через внешний файл или с помощью тега <code>&lt;style></code>,
        но есть исключения.
      </p>

      <h3>
        5. Стили CSS через JavaScript
      </h3>

      <p>
        Практически на каждом современном сайте используются скрипты, написанные на языке JavaScript.
      </p>

      <p>
        В JavaScript есть много различных функций для управления стилями HTML элементов.
        При использовании этих функций CSS свойства добавляются в style атрибут тега.
      </p>

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="http://htmlbook.ru/samcss/sposoby-dobavleniya-stiley-na-stranitsu">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Подключение CSS через внешний файл стилей тегом link',
        isChecked: false,
      },
      {
        name: 'Добавление CSS с помощью тега style',
        isChecked: false,
      },
      {
        name: 'Импорт CSS через команду @import',
        isChecked: false,
      },
      {
        name: 'Inline-стили CSS',
        isChecked: false,
      },
      {
        name: 'Стили CSS через JavaScript',
        isChecked: false,
      },
    ],
  },
  {
    id: 5,
    name: 'Приоритет стилей. Каскадность.',
    answer: `
      <h3>
        Приоритет стилей. Каскадность.
      </h3>

      <p>
        <span class="accent">Каскадность</span> в CSS определяет, как браузер разрешает конфликты стилей, когда к одному элементу применяется несколько правил. Приоритет стилей рассчитывается на основе специфичности селекторов, порядка их объявления и использования <code>!important</code>. Более специфичные селекторы имеют больший вес, а при равной специфичности применяется последнее объявленное правило.
      </p>

      <h3>
        Специфичность селекторов
      </h3>

      <p>
        Это вес, который присваивается CSS-правилу. Рассчитывается как (inline, ID, class/attr/pseudo-class, type/pseudo-element).
      </p>

      <h3>
        Порядок объявления
      </h3>

      <p>
        Если специфичность одинакова, применяется правило, которое было объявлено последним в коде.
      </p>

      <h3>
        !important
      </h3>

      <p>
        Правило с <code>!important</code> имеет наивысший приоритет и переопределяет любые другие стили, независимо от их специфичности.
      </p>

      <h3>
        Источник стилей
      </h3>

      <p>
        Стили браузера (user agent) имеют самый низкий приоритет, затем идут стили пользователя (user), и самый высокий приоритет у стилей автора (author).
      </p>
    `,
    tags: ['css'],
    structure: [
      {
        name: 'Специфичность селекторов',
        isChecked: false,
      },
      {
        name: 'Порядок объявления',
        isChecked: false,
      },
      {
        name: '!important',
        isChecked: false,
      },
      {
        name: 'Источник стилей',
        isChecked: false,
      }
    ],
  },
  {
    id: 6,
    name: '“Вес” селекторов CSS',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 7,
    name: 'Высокая специфичность селектора, есть ли у нее какие-то недостатки?',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 8,
    name: '!important',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 9,
    name: 'Селекторы: > + ~',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 10,
    name: 'Псевдоклассы элементов',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 11,
    name: 'Псевдоклассы форм',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 12,
    name: 'Псевдоэлементы',
    answer: `<span class="accent">Псевдоэлементы</span> — это способ стилизовать те части элемента, которых нет в HTML-разметке (в DOM-дереве), но которые браузер отрисовывает визуально.
    <h3>Основные виды псевдоэлементов</h3>
    Их довольно много, но в реальной работе ты будешь использовать эти 5-6 штук в 90% случаев:

    </br>

    1. Генерируемый контент (<code>::before</code> и <code>::after</code>)
    <p>Самые мощные инструменты верстальщика. Они создают виртуальный элемент, который находится внутри родителя, в самом начале (<code>::before</code>) или в самом конце (<code>::after</code>).</p>

    <p>Для чего: Иконки, декоративные элементы, хлебные крошки, кастомные чекбоксы, очистка потока (clearfix).</p>

    <p>Обязательное условие: Свойство content. Без него (даже если оно пустое <code>content: '';</code>) псевдоэлемент не появится.</p>
    2. Текстовые (<code>::first-letter</code> и <code>::first-line</code>)
    <p><code>::first-letter</code>: Стилизует первую букву блочного элемента (эффект буквицы в книгах).</p>

    <p><code>::first-line</code>: Стилизует первую строку текста. Учти, что длина строки зависит от ширины окна браузера, поэтому стили применяются динамически.</p>

    3. Интерфейсные
    <p><code>::placeholder</code>: Отвечает за стиль текста-подсказки в <code>input</code> и <code>textarea</code>.</p>

    <p><code>::selection</code>: То, как выглядит текст, когда пользователь выделяет его мышкой (обычно меняют <code>background</code> и <code>color</code>).</p>
    <p><code>::marker</code>: Стилизует маркеры (точки/цифры) в списках <code>ul</code> и <code>ol</code>.</p>

    <p>4. Продвинутые (реже используются, но полезны)</p>
    <p><code>::backdrop</code>: Фон, который появляется под элементами в полноэкранном режиме (например, под открытым <code>dialog</code> или видео).</p>
    <p><code>::file-selector-button</code>: Кнопка "Выберите файл" внутри <code>input type="file"</code>.</p>`,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Что такое псевдоэлементы?',
        isChecked: false,
      },
      {
        name: 'Генерируемый контент (::before и ::after)',
        isChecked: false,
      },
      {
        name: 'Текстовые (::first-letter и ::first-line)',
        isChecked: false,
      },
      {
        name: 'Интерфейсные (::placeholder, ::selection, ::marker)',
        isChecked: false,
      },
      {
        name: 'Продвинутые (::backdrop, ::file-selector-button)',
        isChecked: false,
      },
    ],
  },
  {
    id: 13,
    name: 'Позиционирование элементов (absolute, fixed, relative)',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 14,
    name: 'Типы элементов (строчные, блочные и т.д.). Их различия',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 15,
    name: 'Центрирование (горизонтальное, вертикальное)',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 16,
    name: 'Боксовая модель (box-sizing)',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 17,
    name: 'Flexbox VS Grid',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Что такое Flexbox',
        isChecked: false,
      }
    ],
  },
  {
    id: 18,
    name: 'CSS анимации',
    answer: ``,
    tags: ['markup', 'CSS', 'animations'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 19,
    name: 'Сброс стилей и "нормализация" (Reset VS Normilize). Их различия.',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 20,
    name: 'Единицы измерения (em, rem, %, px, vh, vw)',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 21,
    name: 'Порядок подключения ресурсов. Скрипты в head, скрипты в конце body. В чем разница.',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 22,
    name: 'Способы подключить JS на страницу',
    answer: ``,
    tags: ['HTML', 'markup', 'JavaScript'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 23,
    name: 'Атрибуты defer и async у тега script',
    answer: ``,
    tags: ['HTML', 'markup', 'JavaScript'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 24,
    name: 'SVG. Анимации svg',
    answer: ``,
    tags: ['SVG', 'markup', 'animations'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 25,
    name: 'Canvas. Что это и зачем нужен?',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 26,
    name: 'Custom properties',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 27,
    name: 'Pixel-perfect',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 28,
    name: 'Пре- и пост- процессоры CSS. Опыт работы с ними',
    answer: ``,
    tags: ['markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 29,
    name: 'Методология БЭМ. Основные позиции, какие проблемы решает?',
    answer: ``,
    tags: ['HTML', 'markup', 'CSS'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 30,
    name: 'HTML-шаблонизаторы/препроцессоры (handlebars, mustache, pug etc)',
    answer: ``,
    tags: ['HTML', 'markup'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 31,
    name: 'Типы данных (задачи: строка + число)',
    answer: ``,
    tags: ['JavaScript', 'Data types'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 32,
    name: 'Приведение типов в JavaScript',
    answer: ``,
    tags: ['JavaScript', 'Data types'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 33,
    name: 'Структуры данных (массив, объект, set, map)',
    answer: ``,
    tags: ['JavaScript', 'Data types', 'Structures'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 34,
    name: 'Основные методы массивов, которые вы используете',
    answer: `
      <p>
        Массивы предоставляют множество методов. Чтобы было проще, разобьем их на группы.
      </p>

      <h3>
        <strong>Добавление/удаление элементов</strong>
      </h3>

      <p>
        Базовые методы, которые добавляют и удаляют элементы из начала или конца:
      </p>

      <ul>
        <li><code>arr.pop()</code> - извлекает элемент из конца,</li>
        <li><code>arr.push(...items)</code> - добавляет элементы в конец,</li>
        <li><code>arr.shift()</code> - извлекает элемент из начала,</li>
        <li><code>arr.unshift(...items)</code> - добавляет элементы в начало.</li>
      </ul>

      <p>
        Но есть и другие методы для добавления и извлечения...
      </p>

      <h3>
        splice
      </h3>

      <p>
        Как удалить элементы из массива? Да, можно использовать метод delete (поскольку массивы - это тоже объекты).
        Но delete отработает не совсем корректно: он удалит значение элемента, но не сам элемент.
        А нам такое не подходит. Поэтому...
      </p>

      <p>
        Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами.
        Умеет всё: добавлять, удалять и заменять элементы.
      </p>

      <code class="code">
        arr.splice(index[, deleteCount, elem1, ..., elemN]);
      </code>

      <p>
        Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
        Возвращает массив из удалённых элементов.
      </p>

      <code class="code">
        let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

        // удалить 3 первых элемента и заменить их другими
        let removed = arr.splice(0, 3, "Давай", "танцевать");

        alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
        alert( removed ) // "Я", "изучаю", "JavaScript" <-- массив из удалённых элементов
      </code>

      <p class="info info--blue">
        В этом и в других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчёт элементов с конца.
      </p>

      <h3>
        slice
      </h3>

      <p>
        Метод arr.slice намного проще, чем похожий на него arr.splice.
      </p>
      <code class="code">
        arr.slice([start], [end]);
      </code>
      <p>
        Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
        Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
      </p>

      <code class="code">
        let arr = ["t", "e", "s", "t"];

        alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

        alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
      </code>

      <p class="info info--blue">
        Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr.
        Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.
      </p>

      <h3>
        concat
      </h3>

      <p>
        Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
      </p>
      <code class="code">
        arr.concat(arg1, arg2...);
      </code>

      <p>
        Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
      </p>
      <p>
        В результате мы получаем новый массив, включающий в себя элементы из <code>arr</code>,
        а также <code>arg1</code>, <code>arg2</code> и так далее&hellip;
      </p>
      <p>
        Если аргумент <code>argN</code> - массив, то все его элементы копируются. Иначе скопируется сам аргумент.
      </p>

      <code class="code">
        let arr = [1, 2];

        // создать массив из: arr и [3,4]
        alert( arr.concat([3, 4]) ); // 1,2,3,4

        // создать массив из: arr и [3,4] и [5,6]
        alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

        // создать массив из: arr и [3,4], потом добавить значения 5 и 6
        alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
      </code>

      <p>
        Обычно он просто копирует элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:
      </p>
      <code class="code">
        let arr = [1, 2];

        let arrayLike = {
          0: "что-то",
          length: 1
        };

        alert( arr.concat(arrayLike) ); // 1,2,[object Object]
      </code>

      <p>
        Но если объект имеет специальное свойство <code>Symbol.isConcatSpreadable</code>, то он обрабатывается
        <code>concat</code> как массив: вместо него добавляются его числовые свойства.
      </p>
      <p>Для корректной обработки в объекте должны быть числовые свойства и <code>length</code>:</p>
      <code class="code">
        let arr = [1, 2];

        let arrayLike = {
          0: "что-то",
          1: "ещё",
          [Symbol.isConcatSpreadable]: true,
          length: 2
        };

        alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
      </code>

      <h3>
        Перебор: forEach
      </h3>

      <p>
        Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
      </p>
      <code class="code">
        arr.forEach(function(item, index, array) {
          // ... делать что-то с item
        });
      </code>

      <p class="info info--blue">
        Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
      </p>

      <h3>
        <strong>Поиск в массиве</strong>
      </h3>

      <p>
        Методы arr.indexOf,  arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и
        делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:
      </p>

      <ul>
        <li>
          <code>arr.indexOf(item, from)</code> ищет <code>item</code>, начиная с индекса <code>from</code>,
          и возвращает индекс, на котором был найден искомый элемент, в противном случае <code>-1</code>.
        </li>
        <li>
          <code>arr.lastIndexOf(item, from)</code> - то же самое, но ищет справа налево.
        </li>
        <li>
          <code>arr.includes(item, from)</code> - ищет <code>item</code>, начиная с индекса <code>from</code>,
          и возвращает <code>true</code>, если поиск успешен.
        </li>
      </ul>

      <h3>
        find и findIndex
      </h3>

      <p>
        Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?
        Здесь пригодится метод arr.find.
      </p>
      <code class="code">
        let result = arr.find(function(item, index, array) {
          // если true - возвращается текущий элемент и перебор прерывается
          // если все итерации оказались ложными, возвращается undefined
        });
      </code>
      <p>
        Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент,
        а не сам элемент, и -1, если ничего не найдено.
      </p>

      <h3>
        filter
      </h3>
      <p>
        Метод find ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт true.
        На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn).
        </br>
        Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов:
      </p>
      <code class="code">
        let results = arr.filter(function(item, index, array) {
          // если true - элемент добавляется к результату, и перебор продолжается
          // возвращается пустой массив в случае, если ничего не найдено
        });
      </code>

      <h3>
        <strong>Преобразование массива</strong>
      </h3>

      <h3>
        map
      </h3>

      <p>
        Метод arr.map является одним из наиболее полезных и часто используемых.
      </p>
      <p>
        Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
      </p>
      <code class="code">
        let result = arr.map(function(item, index, array) {
          // возвращается новое значение вместо элемента
        });
      </code>

      <p>
        Например, здесь мы преобразуем каждый элемент в его длину:
      </p>
      <code class="code">
        let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
        alert(lengths); // 5,7,6
      </code>

      <h3>
        sort(fn)
      </h3>
      <p>
        Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
      </p>
      <p class="info info--orange">
        Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам входной массив.
      </p>
      <code class="code">
        let arr = [ 1, 2, 15 ];

        // метод сортирует содержимое arr
        arr.sort();

        alert( arr );  // 1, 15, 2
      </code>

      <p>
        Не заметили ничего странного в этом примере?
        Порядок стал 1, 15, 2. Это неправильно! Но почему?
      </p>

      <p class="info info--blue">
        По умолчанию элементы сортируются как строки.
      </p>

      <p>
        Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
      </p>

      <p class="info info--blue">
        На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше»,
        и отрицательное число, чтобы сказать «меньше».
      </p>

      <p>
        Это позволяет писать более короткие функции:
      </p>
      <code class="code">
        let arr = [ 1, 2, 15 ];

        arr.sort( (a, b) => a - b );

        alert(arr);  // 1, 2, 15
      </code>

      <h3>
        reverse
      </h3>
      <p>
        Метод arr.reverse меняет порядок элементов в arr на обратный.
      </p>
      <code class="code">
        let arr = [1, 2, 3, 4, 5];
        arr.reverse();

        alert( arr ); // 5,4,3,2,1
      </code>
      <p class="info info--blue">
        Он также возвращает массив arr с изменённым порядком элементов.
      </p>

      <h3>
        split и join
      </h3>
      <p>
        Методы-антагонисты. split делит строку на массив по заданному разделителю.
      </p>
      <code class="code">
        let names = 'Вася, Петя, Маша';

        let arr = names.split(', '); // ['Вася', 'Петя', 'Маша']
      </code>

      <p>
        У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве.
        Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:
      </p>
      <code class="code">
        let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

        alert(arr); // Вася, Петя
      </code>

      <p class="info info--blue">
        Вызов split(s) с пустым аргументом s разбил бы строку на массив букв и пробелов.
      </p>
      <code class="code">
        'ff f gggg hhhh'.split('');
          // ['f', 'f', ' ', 'f', ' ', 'g', 'g', 'g', 'g', ' ', 'h', 'h', 'h', 'h']
      </code>

      <p>
        Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя разделитель между ними.
      </p>
      <code class="code">
        let arr = ['Вася', 'Петя', 'Маша'];

        let str = arr.join(';'); // объединить массив в строку через: [Вася;Петя;Маша]
      </code>

      <h3>
        reduce/reduceRight
      </h3>
      <p>
        Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее.
        Они используются для вычисления какого-нибудь единого значения на основе всего массива.
      </p>
      <code class="code">
        let value = arr.reduce(function(previousValue, item, index, array) {
          // ...
        }, [initial]);
      </code>
      <p>
        Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.
      </p>
      <p>Аргументы:</p>

      <ul>
        <li>
          <code>previousValue</code> - результат предыдущего вызова этой функции, равен
          <code>initial</code> при первом вызове (если передан <code>initial</code>),
        </li>
        <li><code>item</code> - очередной элемент массива,</li>
        <li><code>index</code> - его индекс,</li>
        <li><code>array</code> - сам массив.</li>
      </ul>

      <p>
        При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.
        Он становится как-бы «аккумулирующим» результат предыдущих вызовов функции. По окончании он становится результатом reduce.
      </p>

      <p>
        Тут мы получим сумму всех элементов массива всего одной строкой:
      </p>
      <code class="code">
        let arr = [1, 2, 3, 4, 5];

        let result = arr.reduce((sum, current) => sum + current, 0); // result = 15
      </code>

      <h3>
        <strong>Array.isArray</strong>
      </h3>
      <p>
        Массивы не образуют отдельный тип языка. Они основаны на объектах.
        </br>
        Поэтому typeof не может отличить простой объект от массива:
      </p>
      <code class="code">
        alert(typeof {}); // object
        alert(typeof []); // тоже object
      </code>

      <p>
        …Но массивы используются настолько часто, что для этого придумали специальный метод:
        Array.isArray(value). Он возвращает true, если value массив, и false, если нет.
      </p>
      <code class="code">
        alert(Array.isArray({})); // false
        alert(Array.isArray([])); // true
      </code>

      <h3>
        <strong>Большинство методов поддерживают «thisArg»</strong>
      </h3>

      <p>
        Почти все методы массива, которые вызывают функции –
        такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg.
      </p>
      <code class="code">
        arr.find(func, thisArg);
          // thisArg - это необязательный последний аргумент
      </code>

      <p>
        Значение параметра thisArg становится this для func.
      </p>

      <h3>
        Источники:
      </h3>
      <ul>
        <li>
          <a href="https://learn.javascript.ru/array-methods#slice">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['JavaScript', 'Data types', 'Structures', 'Iterable', 'Array'],
    structure: [
      {
        name: 'pop/push и shift/unshift, их различия',
        isChecked: false,
      },
      {
        name: 'splice',
        isChecked: false,
      },
      {
        name: 'slice',
        isChecked: false,
      },
      {
        name: 'concat',
        isChecked: false,
      },
      {
        name: 'forEach',
        isChecked: false,
      },
      {
        name: 'indexOf/lastIndexOf и includes, их различия',
        isChecked: false,
      },
      {
        name: 'find и findIndex, их различия',
        isChecked: false,
      },
      {
        name: 'filter',
        isChecked: false,
      },
      {
        name: 'map',
        isChecked: false,
      },
      {
        name: 'sort(fn)',
        isChecked: false,
      },
      {
        name: 'reverse',
        isChecked: false,
      },
      {
        name: 'split и join',
        isChecked: false,
      },
      {
        name: 'reduce',
        isChecked: false,
      },
      {
        name: 'Array.isArray',
        isChecked: false,
      },
      {
        name: '«thisArg»',
        isChecked: false,
      },
    ],
  },
  {
    id: 35,
    name: 'Итераторы',
    answer: ``,
    tags: ['JavaScript', 'Iterable'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 36,
    name: 'Область видимости (Scope)',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 37,
    name: 'Замыкание (Closure)',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 38,
    name: '“Поднятие” переменных и объявлений функций.',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 39,
    name: 'Функции: function declaration, function expression',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics', 'functions'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 40,
    name: 'Let, const и var. Различия',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 41,
    name: 'Рекурсия. Что это такое и для чего нужно?',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 42,
    name: 'Декораторы функций. Что это такое и для чего?',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 43,
    name: 'Ключевое слово this. Контекст',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics', 'context'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 44,
    name: 'Привязка контекста (явная, неявная). Bind, call, apply и их различия',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics', 'context'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 45,
    name: 'Каррирование',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 46,
    name: 'Частичное применение',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 47,
    name: 'Псевдомассив arguments (почему он псевдомассив?)',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics', 'functions'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 48,
    name: '"use strict"; - что это и зачем нужно?',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 49,
    name: 'Преобразование объектов: toString и valueOf',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 50,
    name: 'Цикл событий (Event loop), microtasks, event queue',
    answer: ``,
    tags: ['JavaScript', 'Browser mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 51,
    name: 'Наследование',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 52,
    name: 'Ссылка __proto__. Что это и с чем его едят?',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 53,
    name: 'Свойство F.prototype и создание объектов через new',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 54,
    name: 'Promises. Зачем нужны? Какую проблему решали?',
    answer: `
      <p>
        <code>Promise</code> (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript
        (добавленный в ES6),
        который связывает «создающий» и «потребляющий» коды вместе. «Создающий» код может выполняться сколько потребуется,
        чтобы получить результат. А промис делает результат доступным для кода, который подписан на него, когда результат готов.
      </p>

      <p>
        Синтаксис создания <code>Promise</code>:
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // функция-исполнитель (executor)
          // "певец"
        });
      </code>

      <p>
        Функция, переданная в конструкцию <code>new Promise</code>, называется исполнитель (executor).
        Когда <code>Promise</code> создаётся, она запускается автоматически.
        Она должна содержать «создающий» код, который когда-нибудь создаст результат.
      </p>
      <p>
        Её аргументы <code>resolve</code> и <code>reject</code> – это колбэки, которые предоставляет сам JavaScript.
        Наш код – только внутри исполнителя.
      </p>

      <p>
        Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
      </p>
      <ul>
        <li><code>resolve(value)</code> - если работа завершилась успешно, с результатом <code>value</code>.</li>
        <li><code>reject(error)</code> - если произошла ошибка, <code>error</code> - объект ошибки.</li>
      </ul>

      <p>
        У объекта <code>Promise</code>, возвращаемого конструктором <code>new Promise</code>, есть внутренние свойства:
      </p>
      <ul>
        <li>
          <code>state</code> ("состояние") - вначале <code>&quot;pending&quot;</code> ("ожидание"),
          потом меняется на <code>&quot;fulfilled&quot;</code> ("выполнено успешно") при вызове
          <code>resolve</code> или на <code>&quot;rejected&quot;</code> ("выполнено с ошибкой") при вызове <code>reject</code>.
        </li>
        <li>
          <code>result</code> ("результат") - вначале <code>undefined</code>, далее изменяется на <code>value</code>
          при вызове <code>resolve(value)</code> или на <code>error</code> при вызове
          <code>reject(error)</code>.
        </li>
      </ul>

      <p>
        Так что исполнитель по итогу переводит promise в одно из двух состояний:
      </p>
      <img src="../assets/img/promise.jpg">

      <p>
        Ниже пример конструктора Promise и простого исполнителя с кодом, дающим результат с задержкой (через setTimeout):
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // эта функция выполнится автоматически, при вызове new Promise

          // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
          setTimeout(() => resolve("done"), 1000);
        });
      </code>

      <p>
        А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
          setTimeout(() => reject(new Error("Whoops!")), 1000);
        });
      </code>

      <p class="info info--blue">
        <strong>Может быть что-то одно: либо результат, либо ошибка</strong></br>
        Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.
      </p>

      <p class="info info--blue">
        <strong>Вызов resolve/reject сразу</strong></br>
        Обычно исполнитель делает что-то асинхронное и после этого вызывает resolve/reject,
        то есть через какое-то время. Но это не обязательно, resolve или reject могут быть вызваны сразу:
      </p>
      <code class="code">
        let promise = new Promise(function(resolve, reject) {
          // задача, не требующая времени
          resolve(123); // мгновенно выдаст результат: 123
        });
      </code>

      <h3>
        Потребители: then, catch, finally
      </h3>
      <p>
        Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»),
        которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов
        .then, .catch и .finally.
      </p>

      <h3>
        then
      </h3>
      <p>
        Наиболее важный и фундаментальный метод – .then.
      </p>
      <code class="code">
        promise.then(
          function(result) { /* обработает успешное выполнение */ },
          function(error) { /* обработает ошибку */ }
        );
      </code>
      <p>
        Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:
      </p>

      <h3>
        catch
      </h3>
      <p>
        Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента:
        <code>.then(null, errorHandlingFunction)</code>. Или можно воспользоваться методом
        <code>.catch(errorHandlingFunction)</code>, который сделает то же самое
      </p>
      <code class="code">
        let promise = new Promise((resolve, reject) => {
          setTimeout(() => reject(new Error("Ошибка!")), 1000);
        });

        // .catch(f) это то же самое, что promise.then(null, f)
        promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
      </code>

      <h3>
        finally
      </h3>

      <p>
        По аналогии с блоком <code>finally</code> из обычного <code>try {...} catch {...}</code>,
        у промисов также есть метод <code>finally</code>.
      </p>

      <p>
        Вызов <code>.finally(f)</code> похож на <code>.then(f, f)</code>, в том смысле, что <code>f</code>
        выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
      </p>

      <p>
        <code>finally</code> хорошо подходит для очистки, например остановки индикатора загрузки,
        его ведь нужно остановить вне зависимости от результата.
      </p>
      <code class="code">
        new Promise((resolve, reject) => {
          /* сделать что-то, что займёт время, и после вызвать resolve/reject */
        })
          // выполнится, когда промис завершится, независимо от того, успешно или нет
          .finally(() => остановить индикатор загрузки)
          .then(result => показать результат, err => показать ошибку)
      </code>

      <p>Но это не совсем псевдоним <code>then(f,f)</code>, как можно было подумать. Существует несколько важных отличий:</p>

      <ol>
        <li>
          <p>
            Обработчик, вызываемый из <code>finally</code>, не имеет аргументов. В <code>finally</code> мы не знаем, к
            ак был завершён промис. И это нормально, потому что обычно наша задача -
            выполнить "общие" завершающие процедуры.
          </p>
        </li>
        <li>
          <p>Обработчик <code>finally</code> "пропускает" результат или ошибку дальше, к последующим обработчикам.</p>
        </li>
      </ol>

      <h3>
        Цепочка вызовов
      </h3>
      <p>
        Общая нужда - выполнять две или более асинхронных операции одна за другой, причём каждая следующая начинается
        при успешном завершении предыдущей и использует результат её выполнения.
      </p>
      <code class="code">
        let promise = doSomething();

        doSomething()
          .then(result => doSomethingElse(result))
          .then(newResult => doThirdThing(newResult))
          .then(finalResult => {
            console.log('Итоговый результат: \${ finalResult }');
          })
          .catch(failureCallback);
      </code>

      <p class="info info--blue">
        <strong>Можно продолжить цепочку вызовов после ошибки</strong></br>
        Т.е. после catch, что полезно для выполнения новых действий даже
        после того, как действие вернёт ошибку в цепочке вызовов.
      </p>

      <code class="code">
        new Promise((resolve, reject) => {
          console.log('Начало');

          resolve();
        })
        .then(() => {
          throw new Error('Где-то произошла ошибка');

          console.log('Выведи это');
        })
        .catch(() => {
          console.log('Выведи то');
        })
        .then(() => {
          console.log('Выведи это, несмотря ни на что');
        });
      </code>
      <p>
        В результате получим:
      </p>
      <code class="code">
        Начало
        Выведи то
        Выведи это, несмотря ни на что
      </code>

      <p class="info info--blue">
        <strong>Можно строить такие цепочки и с finally.</strong></br>
        Обработчик <code>finally</code> "пропускает" результат или ошибку дальше, к последующим обработчикам.
      </p>

      <h3>
        Какую проблему решали промисы
      </h3>
      <p>
        До появления «обещаний» асинхронные задачи можно было решать с помощью функций обратного вызова или с помощью обработки событий.
        Универсальный подход к решению асинхронных задач – обработка событий.
        Вариант решения задач с помощью «обещаний», скорее, призван заменить подход к функциям обратного вызова.
      </p>

      <p>
        В использовании функций обратного вызова есть существенный недостаток с точки зрения организации кода: "callback hell".
        Этот недостаток заключается в том, что в функции обратного вызова есть параметр, который, в свою очередь,
        также является функцией обратного вызова – и так может продолжаться до бесконечности.
      </p>

      <p>
        Может образоваться несколько уровней таких вложенностей. Это приводит к плохому чтению кода и запутанности между вызовами
        функций обратного вызова. Это, в свою очередь, приведет к ошибкам. С такой структурой кода найти ошибки очень сложно.
      </p>

      <h3>
        Источники:
      </h3>
      <ul>
        <li>
          <a href="https://learn.javascript.ru/promise-basics">Источник 1 (теория)</a>
        </li>
        <li>
          <a href="https://habr.com/ru/company/zerotech/blog/317256/">Источник 2 (зачем нужны)</a>
        </li>
      </ul>
    `,
    tags: ['JavaScript', 'JS mechanics', 'Promise', 'Async'],
    structure: [
      {
        name: 'Что такое Promise, в какой версии ES появился',
        isChecked: false,
      },
      {
        name: 'Неизменность результата после завершения промиса',
        isChecked: false,
      },
      {
        name: 'then, catch, finally',
        isChecked: false,
      },
      {
        name: 'Цепочка вызовов',
        isChecked: false,
      },
      {
        name: 'Какую проблему решали промисы',
        isChecked: false,
      },
    ],
  },
  {
    id: 55,
    name: 'Promise chaining. Можно ли вызывать promise.then().finally().then() или promise.catch().then()? Что получим?',
    answer: ``,
    tags: ['JavaScript', 'JS mechanics', 'Promise', 'Async'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 56,
    name: 'Try - Catch. Что это и для чего нужно?',
    answer: ``,
    tags: ['JavaScript'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 57,
    name: 'Что нового появилось в языке в ES6?',
    answer: ``,
    tags: ['JavaScript', 'ES6'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 58,
    name: 'Что нового появилось в языке ПОСЛЕ ES6?',
    answer: ``,
    tags: ['JavaScript', 'ES6', 'ES7'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 59,
    name: 'Async await. Кто такие и какую проблему решают?',
    answer: ``,
    tags: ['JavaScript', 'ES6', 'Promise', 'Async'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 60,
    name: 'DOM. Что это и зачем нужно?',
    answer: ``,
    tags: ['HTML', 'markup', 'browser mechanics', 'browser'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 61,
    name: 'DOM события. Всплытие, погружение. Делегирование',
    answer: ``,
    tags: ['markup', 'browser mechanics', 'browser'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 62,
    name: 'LocalStorage VS SessionStorage. Различия, принцип работы',
    answer: ``,
    tags: ['markup', 'browser', 'LocalStorage', 'SessionStorage'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 63,
    name: 'Code style. Linters. Prittier',
    answer: ``,
    tags: ['programming', 'codestyle', 'best-practice'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 64,
    name: 'Мутабильность/иммутабильность (при работ с массивами etc)',
    answer: ``,
    tags: ['programming', 'immutable'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 65,
    name: 'Реактивное программирование. RxJs и основные методы',
    answer: `
      <h3>Реактивное программирование — программирование с асинхронными потоками данных.</h3>

      <p>
        Впрочем, ничего нового. Event bus’ы или обычные события клика — это тоже асинхронные потоки данных,
        которые вы можете прослушивать, чтобы реагировать какими-либо действиями.
        <br>
        <span class="accent">Реактивность</span> — это та же самая идея,
        возведенная в абсолют. Вы можете создавать потоки данных не только из событий наведения или кликания мышью.
        Потоком может быть что угодно: переменные, пользовательский ввод, свойства, кэш, структуры данных и т.п.
        <br>
        Например, представьте, что ваша лента новостей в Твиттере — поток событий. Вы можете слушать этот поток и
        реагировать на события соответственно.
      </p>

      <p>
        <span class="accent">Поток</span> — это последовательность событий, упорядоченная по времени. Он может выбрасывать три типа данных:
        значение (определенного типа), ошибку или сигнал завершения.
        <br>
        Мы перехватываем эти события асинхронно, указывая одну функцию, которая будет вызываться,
        когда выброшено значение, другую для ошибок и третью для обработки сигнала завершения.
      </p>

      <h3>Для чего нужно реактивное программирование</h3>

      <p>
        Реактивный подход повышает уровень абстракции вашего кода и вы можете сконцентрироваться на взаимосвязи событий,
        которые определяют бизнес-логику, вместо того, чтобы постоянно поддерживать код с большим количеством деталей реализации.
        Код в реактивном программировании, вероятно, будет короче.
      </p>

      <p>
        Преимущество более заметно в современных веб- и мобильных приложениях, которые работают с большим количеством
        разнообразных UI-событий. 10 лет назад всё взаимодействие с веб-страницей сводилось к отправке больших форм на
        сервер и выполнении простого рендеринга в клиентской части. Сейчас приложения более сложны: изменение одного поля может
        повлечь за собой автоматическое сохранение данных на сервере, информация о новом «лайке» должна отправиться
        другим подключенным пользователям и т.д.
      </p>

      <p>
        Реактивное программирование очень хорошо подходит для обработки большого количества разнообразных событий.
      </p>

      <h3>
        О библиотеке RxJs
      </h3>

      <p>
        <span class="accent">RxJS</span> представляет собой библиотеку, позволяющую управлять всеми асинхронными операциями и событиями в
        приложении в стиле реактивного программирования. Она построена на основе паттерна проектирования <code>Observer</code>
        и предусматривает целый ряд операторов для манипуляции асинхронными событиями и обработки передаваемых ими данных.
      </p>

      <h3>
        Ключевые понятия RxJS:
      </h3>

      <ul>
        <li><code>Observable</code>;</li>
        <li><code>Observer</code>;</li>
        <li><code>Subject</code>;</li>
        <li><code>Scheduler</code>;</li>
        <li><code>Subscription</code>;</li>
        <li><code>Operator</code>.</li>
      </ul>

      <p>
        RxJS оперирует объектами <code>Observable</code>, которые существуют в нескольких разновидностях
        (<code>Subject</code>, <code>Scheduler</code>) и реализуют принцип push-систем передачи данных от &quot;поставщика&quot;
        к &quot;потребителю&quot;.
      </p>

      <p>
        Помимо push-систем выделяют еще и pull-системы передачи данных.
      </p>

      <p>
        В pull-системах "потребитель" решает, когда получить данные от "поставщика".
        Любая JavaScript функция - яркий пример такой системы. Код вызова функции - "потребитель", сама функция - "поставщик".
      </p>

      <p>
        В случае с RxJS <code>Observable</code> именно отправитель решает, когда отправить данные получателю.
        К этому типу push-систем относятся и объекты <code>Promise</code>, которые предоставляют данные зарегистрированным
        callback-функциям и инициируют их вызов.
      </p>

      <p class="info info--blue">
        Преимущество объектов <code>Observable</code> в том, что они могут передавать данные множество раз в разные моменты
        времени множеству "потребителей".
      </p>

      <p>
        В контексте приложений Angular RxJS применяется для выполнения HTTP-запросов,
        отслеживания событий браузера или создания пользовательских и других событий.
      </p>

      <p>
        Пример создания простого Observable с использованием функции fromEvent:
      </p>

      <code class="code">
        import { fromEvent } from 'rxjs';

        fromEvent(document, 'mousemove').subscribe((ev) => {
          console.log('Mouse event: ', ev);
        });
      </code>

      <p>
        Здесь регистрируется обработчик, который при движении мыши в пределах всего документа в консоль будет
        выводить полную информации о событии.
      </p>
    `,
    tags: ['TypeScript', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 66,
    name: 'Что такое объект Observable в RxJs?',
    answer: `
      <code><em>Observable</em></code> — это последовательность событий во времени.

      <p>
        В RxJS зритель подписывается на <code>Observable</code> (зрелище).
        Подписавшийся зритель реагирует на каждое событие, которое происходит во время зрелища.
      </p>
      <p>
        Объекты RxJS <code>Observable</code> создаются либо с использованием операторов создания
        (<code>of</code>, <code>from</code>, <code>fromEvent</code>), либо через <code>new Observable</code>.
      </p>
      <p>
        Пример с оператором <code>of()</code>:
      </p>
      <code class="code">
        of('Hello').subscribe((vl) => console.log(vl));
      </code>

      <p>
        Пример с <code>new Observable</code>:
      </p>
      <code class="code">
        const obs = new Observable((sub) => {
          sub.next(1);

          setTimeout(() => {
            sub.next(3);
            sub.complete();
          }, 500);
        });

        obs.subscribe((vl) => console.log(vl));
      </code>
      <p>
        Каждый <code>Observable</code> может отправлять своим "зрителям" уведомления вызовом одного из трех методов:
      </p>
      <ul>
        <li> <code>next()</code> - отправка данных, количество вызовов не ограничено;</li>
        <li>
          <code>error()</code> - генерация ошибки, параметром указываются данные любого формата
          (строка, объект, исключение) о причине ее возникновения;
        </li>
        <li>
          <code>complete()</code> - завершение исполнения <code>Observable</code>, не принимает
          никаких параметров и не передает никакого значения.
        </li>
      </ul>

      <p>
        Но исполнение RxJS <code>Observable</code> начнется только после вызова у него метода <code>subscribe()</code>,
        который принимает функцию с передаваемыми данными в качестве аргумента.
        Вторым и третьим необязательными параметрами методу <code>subscribe()</code> можно передать функции,
        которые будут вызваны в случае ошибки или (и) завершения <code>Observable</code>.
      </p>
      <code class="code">
        const obs = new Observable((sub) => {
          sub.next(1);

          setTimeout(() => {
            sub.error(3);
          }, 500);
        });

        obs.subscribe(
          (vl) => console.log(vl),
          (err) => console.log('Error: ', err),
          () => console.log('Completed')
        );
      </code>
      <p class="info info--blue">
        Вызов <code>error()</code> или <code>complete()</code> автоматически завершает исполнение <code>Observable</code>.
      </p>
      <p>
        Количество вызовов исполнения такого объекта не ограничено, а сам он даже не знает, сколько "зрителей" получает от него данные.
      </p>
      <p>
        Метод <code>subscribe()</code> возвращает объект типа <code>Subscription</code>, который хранит текущее исполнение
        конкретного RxJS <code>Observable</code> и имеет единственный метод <code>unsubscribe()</code>
        для отмены его исполнения.
      </p>
      <code class="code">
        const sub = obs.subscribe();
        sub.unsubscribe();
      </code>
      <p>
        Вызов <code>unsubscribe()</code> нужен только для бесконечно исполняемых
        <code>Observable</code>, иначе занимаемые ими ресурсы будут освобождены только с окончанием
        работы всего приложения. А значит в процессе работы программы может произойти утечка памяти
        или могут быть созданы ненужные дублирующиеся "зрители".
      </p>
      <p>
        Например, последнее может произойти, когда пользователь зашел на страницу, инициирующую исполнение
        RxJS <code>Observable</code>, затем перешел на другой URL и вернулся обратно.
      </p>
      <p>
        Бесконечно исполняемыми <code>Observable</code> считаются те из них, которые никогда не вызывают метод
        <code>complete()</code>, даже если у них предусмотрен сценарий, при котором произойдет обращение к
        <code>error()</code>, что также завершит исполнение.
      </p>
      <p class="info info--blue">
        В Angular приложении <code>unsubscribe()</code> обычно вызывается на
        стадии жизненного цикла <code>OnDestroy()</code> того компонента, в котором используется <code>Observable</code>.
      </p>
    `,
    tags: ['TypeScript', 'Observables', 'Async', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 67,
    name: 'Что такое Subject? Какие бывают виды?',
    answer: `
      <h3>Что такое Subject</h3>

      <p>
        <span class="accent">Subject</span> - это разновидность объектов <code>Observable</code> в RxJS.
        <code>Subject</code> одновременно является и зрителем и зрелищем - соответственно, имеет методы как зрелища, так и зрителя.
        <br>
        Особенность <code>Subject</code> в том, что он может отправлять данные одновременно множеству "потребителей",
        которые могут регистрироваться уже в процессе исполнения <code>Subject</code>,
        в то время как исполнение стандартного <code>Observable</code> осуществляется уникально для каждого его вызова.
      </p>

      <p>
        Объекты RxJS Subject реализуют принцип работы событий, поддерживая возможность регистрировать неограниченное
        количество обработчиков отправляемых ими данных.
      </p>

      <p>
        Рассмотрим пример.
      </p>

      <code class="code">
        const sbj = new Subject<number>();

        sbj.subscribe((vl) => console.log('1st: $\{ vl }'));
        sbj.next(3);
        sbj.subscribe((vl) => console.log('2nd: $\{ vl }'));
        sbj.next(9);

        /*
        Результат  в консоли:

        1st: 3
        1st: 9
        2nd: 9
        */
      </code>

      <p>
        Создание происходит с помощью <code>new Subject()</code>. Далее регистрируются обработчики вызовом метода
        <code>subscribe()</code>, принимающего подобно обычному <code>Observable</code> три функции:
        <code>next()</code>, <code>error()</code> и <code>complete()</code>.
      </p>

      <p>
        Но здесь обработчики исполняются не сразу в момент вызова <code>subscribe()</code>,
        а после обращения к методам <code>next()</code>, <code>error()</code> или
        <code>complete()</code> самого объекта.
      </p>

      <p>
        Причем регистрация новых "потребителей" может происходить в любой момент времени. Но получать данные они
        будут уже начиная со следующей рассылки.
      </p>

      <p class="info info--blue">
        Объекты RxJS Subject по умолчанию являются бесконечно исполняемыми, так как заранее неизвестно,
        когда будет вызов complete() и будет ли он вызван вообще. Поэтому не стоит забывать про unsubscribe().
      </p>

      <h3>В RxJS имеется несколько разновидностей Subject</h3>
      <ul>
        <li><a href="https://rxjs.dev/api/index/class/BehaviorSubject"><code>BehaviorSubject</code></a>,</li>
        <li><a href="https://rxjs.dev/api/index/class/ReplaySubject"><code>ReplaySubject</code></a>,</li>
        <li><a href="https://rxjs.dev/api/index/class/AsyncSubject"><code>AsyncSubject</code></a>.</li>
      </ul>

      <h3>BehaviorSubject</h3>

      <p>
        <code>BehaviorSubject</code> хранит в себе последнее отправленное им значение.
        Так, каждому новому обработчику в момент регистрации (вызов <code>subscribe()</code>) будет отправлено это значение.
      </p>

      <p>
        Начальное значение задается в момент создания RxJS <code>BehaviorSubject</code>.
      </p>

      <code class="code">
        const sbj = new BehaviorSubject<number>(5);

        sbj.subscribe((vl) => console.log('1st: $\{ vl }'));
        sbj.subscribe((vl) => console.log('2nd: $\{ vl }'));
        sbj.next(7);

        /*
        Результат  в консоли:

        1st: 5
        2nd: 5
        1st: 7
        2nd: 7
        */
      </code>

      <h3>ReplaySubject</h3>

      <p>
        В отличие от <code>BehaviorSubject</code> объекты <code>ReplaySubject</code>
        способны хранить заданное количество последних значений, которое задается при создании объекта.
      </p>

      <code class="code">
        const sbj = new ReplaySubject(2);
        /*
          Внимание! Цифра 2 в скобках - количество последних обновлений, которые получит новый подписчик.
          Если его убрать, то будут продублированы все, а так - только 2 последних
        */

        sbj.next(5);

        sbj.subscribe((vl) => console.log('1st: $\{ vl }'));

        sbj.next(6);
        sbj.next(7);

        sbj.subscribe((vl) => console.log('2nd: $\{ vl }'));

        /*
        Результат  в консоли:

        1st: 5
        1st: 6
        1st: 7
        2nd: 6
        2nd: 7
        */
      </code>

      <p>
        Все новые "потребители" сразу же получают по очереди все
        <code>n</code> (в данном случае - 2) указанных значений RxJS <code>ReplaySubject</code>.
      </p>

      <h3>AsyncSubject</h3>

      <p>
        В случае с <code>AsyncSubject</code> "потребителям" передается только последнее значение объекта и
        только, когда он завершит свое выполнение (вызов <code>complete()</code>).
      </p>

      <code class="code">
        const sbj = new AsyncSubject();

        sbj.subscribe((vl) => console.log('Async: $\{ vl }'));

        sbj.next(7);
        sbj.next(8);
        sbj.next(9);

        setTimeout(() => sbj.complete(), 3000);

        /*
        Результат  в консоли (по истечении 3 сек):

        Async: 9
        */
      </code>
    `,
    tags: ['TypeScript', 'Observables', 'Async', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 68,
    name: 'Observables VS Subject - различия',
    answer: `
      <p>
        <span class="accent">Subject</span> - это разновидность объектов <code>Observable</code> в RxJS.
        <code>Subject</code> одновременно является и зрителем и зрелищем - соответственно, имеет методы как зрелища, так и зрителя.
        <br>
        Особенность <code>Subject</code> состоит в том, что здесь обработчики исполняются не сразу в момент вызова
        <code>subscribe()</code>, а после обращения к методам <code>next()</code>, <code>error()</code> или
        <code>complete()</code> самого объекта.
      </p>

      <p>
        <code>Subject</code> имеет несколько типов, поведение которых отличается между собой.
        Соответственно, их использование зависит от конкретных целей.
      </p>

      <ul>
        <li>
          <a href="https://rxjs.dev/api/index/class/BehaviorSubject"><code>BehaviorSubject</code></a> -
          хранит в себе последнее отправленное им значение.
        </li>
        <li>
          <a href="https://rxjs.dev/api/index/class/ReplaySubject"><code>ReplaySubject</code></a> -
          способны хранить заданное количество последних значений, которое задается при создании объекта.
        </li>
        <li>
          <a href="https://rxjs.dev/api/index/class/AsyncSubject"><code>AsyncSubject</code></a> -
          возвращает только последнее значение объекта и только, когда он завершит свое выполнение (вызов complete()).
        </li>
      </ul>

      <p>
        <span class="accent">Observable</span> - это просто некоторый асинхронный поток данных.
        <br>
        Данный механизм позволяет создавать объекты, инициирующие асинхронные потоки (stream или observable)
        и объекты, которые за ними наблюдают (observer).
      </p>

      <code class="code">
        import { Observable } from 'rxjs';

        const observable = new Observable(subscriber => {
          subscriber.next(1);
          subscriber.next(2);
          subscriber.next(3);
          setTimeout(() => {
            subscriber.next(4);
            subscriber.complete();
          }, 1000);
        });

        console.log('just before subscribe');
        observable.subscribe({
          next(x) { console.log('got value ' + x); },
          error(err) { console.error('something wrong occurred: ' + err); },
          complete() { console.log('done'); }
        });

        console.log('just after subscribe');
      </code>

      <p>
        Выполнение кода, описанного выше, выведет в консоли следующее:
      </p>

      <code class="code">
        just before subscribe
        got value 1
        got value 2
        got value 3
        just after subscribe
        got value 4
        done
      </code>

      <h3>
        Подытожим.
      </h3>

      <p>
        Используя <code>Subject</code>, мы можем не только получать изменения, подписавшись на них,
        но и транслировать их через <code>next()</code>.

        Если же говорить о <code>Observable</code>, то тут всё проще - они позволяют транслировать события только в момент инициализации.
        Таким образом, в коде мы можем использовать их ТОЛЬКО для получения изменений, используя метод <code>subscribe()</code>.
      </p>
    `,
    tags: ['TypeScript', 'Observables', 'Async', 'RxJs'],
    structure: [
      {
        name: 'Специфика Subject',
        isChecked: false,
      },
      {
        name: 'Различия поведения и виды Subject',
        isChecked: false,
      },
      {
        name: 'Специфика Observable',
        isChecked: false,
      },
      {
        name: 'Observable - только на получение данных, Subject - ещё и для распространения',
        isChecked: false,
      }
    ],
  },
  {
    id: 69,
    name: 'Zone.js. Что это и для чего нужно?',
    answer: ``,
    tags: ['TypeScript', 'TS mechanics', 'Async'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 70,
    name: 'Механизм Change Detection',
    answer: ``,
    tags: ['TypeScript', 'TS mechanics'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 71,
    name: 'Lifecycle Angular (Жизненный цикл компонента)',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 72,
    name: 'Что такое Enums? Их применение',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 73,
    name: 'Class, Interface. Различия и применение',
    answer: ``,
    tags: ['TypeScript', 'Angular', 'ООП'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 74,
    name: 'Что такое Generics? Их применение',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 75,
    name: 'Что такое never в TypeScript?',
    answer: ``,
    tags: ['TypeScript', 'Angular'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 76,
    name: 'Когда использовать .asObservable() в RxJs?',
    answer: `
      <p>
        Смысл использования <code>Subject.prototype.asObservable()</code> состоит в том, чтобы предотвратить
        утечку &quot;observer side&quot; из API (предотвратить утечку абстракции, когда вы не хотите,
        чтобы кто-либо мог вызвать метод <code>next()</code> у возвращаемого значения).
      </p>
      <code class="code">
        const myAPI = {
          getData: () =&gt; {
            const subject = new Subject();
            const source = new SomeWeirdDataSource();
            source.onMessage = (data) =&gt; subject.next({ type: &#39;message&#39;, data });
            source.onOtherMessage = (data) =&gt; subject.next({ type: &#39;othermessage&#39;, data });
            return subject.asObservable();
          }
        };
      </code>

      <p>Теперь, когда кто-то получит результат от <code>myAPI.getData()</code> , он не может вызвать метод next():</p>

      <code class="code">
        const result = myAPI.getData();
        result.next(&#39;LOL hax!&#39;); // throws an error because next doesn&#39;t exist
      </code>

      <p>
        В целом, это хорошая практика - инкапсулировать логику по управлению потоками данных внутри сервисов и не давать
        возможности менять эти данные извне без особой необходимости.
      </p>

      <p>
        Однако, в этом подходе также есть пара моментов, которые стоит учитывать. Во-первых,
        <code>getData()</code>
        не ленив, как большинство наблюдаемых, он немедленно создаст базовый источник данных
        <code>SomeWeirdDataSource</code>
        (и, предположительно, некоторые побочные эффекты).
        Во-вторых, на выходе <code>getData()</code> возвращает <code>return subject.asObservable();</code>,
        которое каждый раз будет новым наблюдаемым.;
      </p>

      <p>
        Таким образом, использовать этот подход следует с осторожностью.
        Также следует вынести часть с созданием <code>new Subject</code> за пределы этой функции,
        дабы не создавать новую сущность при каждом вызове (например, производить инициализацию
        <code>Subject</code> в корне компонента).
      </p>
    `,
    tags: ['TypeScript', 'Angular', 'RxJs'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 77,
    name: 'Основные принципы ООП',
    answer: ``,
    tags: ['programming', 'ООП'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 78,
    name: 'Знания в архитектуре - паттерны проектирования',
    answer: ``,
    tags: ['programming', 'best-practice'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 79,
    name: 'SOLID. Что это такое и зачем?',
    answer: ``,
    tags: ['programming', 'best-practice', 'ООП'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 80,
    name: 'Протокол HTTP. Что это такое и с чем его едят?',
    answer: ``,
    tags: ['protocol', 'internet'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 81,
    name: 'CORS. Что это такое и с чем его едят?',
    answer: ``,
    tags: ['internet'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 82,
    name: 'Специальные селекторы. Псевдоклассы :host, :host-context и псевдоэлемент ::ng-deep',
    answer: `
      <p>
        Стили компонентов имеют несколько специальных селекторов из мира shadow DOM
        (описаны на странице <code>CSS Scoping Module Level 1</code> на сайте W3C).
        Давайте познакомимся с этими селекторами поближе.
      </p>

      <h3>:host</h3>
      <p>
        Каждый компонент связан с элементом в верстке, который носит его имя-селектор.
        Этот элемент называется хост-элементом, в него рендерится шаблон.
        Селектор псевдокласса <code>:host</code> может использоваться чтобы создавать стили
        для самого элемента хоста, а не элементов внутри него.
      </p>
      <p>
        Стили, описанные в <code>:host</code> будут нацелены на основной элемент компонента.
        Любое правило, примененное к этому селектору псевдокласса, повлияет на основной элемент и все
        его потомки.
      </p>
      <p>
        Селектор псевдокласса <code>:host</code> нацелен только на хост-элемент компонента.
        Любые стили в блоке <code>:host</code> дочернего компонента не повлияют на родительские компоненты.
      </p>
      <p>
        Используйте форму функции для условного применения стилей хоста, включив другой селектор в круглые скобки после <code>:host</code>.
      </p>
      <code class="code">
        :host {
          font-style: italic;
        }

        :host(.active) {
          font-weight: bold;
        }
      </code>
      <p>
        Селектор псевдокласса <code>:host</code> можно комбинировать с другими селекторами.
      </p>

      <h3>:host-context</h3>
      <p>
        Иногда полезно применять стили к элементам в шаблоне компонента
        на основе некоторого условия в элементе-предке основного элемента.
        Например, класс цветовой темы CSS может быть применен к элементу документа <code>< body ></code>,
        и вы хотите изменить внешний вид вашего компонента на основе этого.
      </p>
      <p>
        Селектор псевдокласса <code>:host-context()</code> работает так же, как
        функциональная форма <code>:host()</code>. Селектор <code>:host-context()</code> ищет класс CSS в
        любом предке хост-элемента компонента, вплоть до корня документа.
      </p>
      <code class="code">
        :host-context(.active) {
          font-style: italic;
        }
      </code>
      <p>
        Обратите внимание, что будут затронуты только основной элемент и его потомки, а не предок с назначенным активным классом.
      </p>

      <h3>(deprecated) /deep/, >>>, and ::ng-deep</h3>
      <p>
        Стили компонентов обычно применяются только к HTML в собственном шаблоне компонента.
      </p>
      <p>
        Применение псевдокласса <code>::ng-deep</code> к любому правилу CSS полностью отключает инкапсуляцию
        представления для этого правила. При этом стиль становится глобальным стилем.
        Чтобы применить указанный стиль к текущему компоненту и всем его потомкам,
        обязательно включите селектор <code>:host</code> перед <code>::ng-deep</code>.
        Если псевдокласса <code>::ng-deep</code> используется без селектора псевдокласса <code>:host</code>,
        стиль может просачиваться в другие компоненты.
      </p>
      <p>
        Следующий пример предназначен для всех элементов <code>< h3 ></code>, начиная с основного
        элемента и вниз по дереву его дочерних DOM-элементов.
      </p>
      <code class="code">
        :host ::ng-deep h3 {
          font-style: italic;
        }
      </code>
      <p>
        Псевдокласса <code>/deep/</code> также имеет псевдонимы <code>>>></code> и <code>::ng-deep</code>.
      </p>
      <p class="info info--orange">
        Селектор псевдокласса потомков <code>::ng-deep</code> устарел, и его поддержка прекращается в основных браузерах и инструментах.
        Таким образом, мы планируем отказаться от поддержки в Angular
        (для всех 3 псевдоклассов: <code>/deep/</code>, <code>>>></code> и <code>::ng-deep</code>).<br>
        До тех пор следует отдавать предпочтение <code>::ng-deep</code> для более широкой совместимости с инструментами.
      </p>
    `,
    tags: ['Angular', 'html', 'markup'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
  {
    id: 83,
    name: 'SQL. Основные команды',
    answer: `
      <h3>Структура sql-запросов</h3>

      <p>Общая структура запроса выглядит следующим образом:</p>
      <code class="code">
        SELECT ('столбцы или * для выбора всех столбцов; обязательно')
        FROM ('таблица; обязательно')
        WHERE ('условие/фильтрация, например, city = 'Moscow'; необязательно')
        GROUP BY ('столбец, по которому хотим сгруппировать данные; необязательно')
        HAVING ('условие/фильтрация на уровне сгруппированных данных; необязательно')
        ORDER BY ('столбец, по которому хотим отсортировать вывод; необязательно')
      </code>
      </br>

      <h3>Команды SQL, которые должен знать каждый программист:</h3>

      <code>
        SELECT, FROM
      </code>
      <p>
        SELECT, FROM — обязательные элементы запроса, которые определяют выбранные столбцы, их порядок и источник данных.
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>;
      </code>
      <p>
        Выбрать все (обозначается как *) из таблицы Customers:
      </p>
      <code class="code">
        SELECT * FROM Customers
      </code>
      </br>

      <code>
        SELECT DISTINCT
      </code>
      <p>
        В столбцах таблицы могут содержаться повторяющиеся данные. Используйте SELECT DISTINCT для получения только неповторяющихся данных.
      </p>
      <code class="code">
        SELECT DISTINCT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>;
      </code>
      </br>

      <code>
        WHERE
      </code>
      <p>
        WHERE — необязательный элемент запроса, который используется, когда нужно отфильтровать данные по нужному условию.
        Очень часто внутри элемента where используются IN / NOT IN для фильтрации столбца по нескольким значениям,
        AND / OR для фильтрации таблицы по нескольким столбцам.
        </br>
        Можно использовать ключевое слово WHERE в SELECT для указания условий в запросе:
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;condition>;
      </code>
      <p>
        В запросе можно задавать следующие условия:
      </p>
      <ul>
        <li>сравнение текста;</li>
        <li>сравнение численных значений;</li>
        <li>логические операции AND (и), OR (или) и NOT (отрицание).</li>
      </ul>

      <p>
        Фильтрация по одному условию и одному значению:
      </p>
      <code class="code">
        SELECT * FROM Customers
          WHERE City = 'London'
      </code>
      <p>
        Фильтрация по одному условию и нескольким значениям с применением IN (включение) или NOT IN (исключение):
      </p>
      <code class="code">
        SELECT * FROM Customers
          WHERE City IN ('London', 'Berlin')
      </code>
      </br>
      <code class="code">
        SELECT * FROM Customers
          WHERE City NOT IN ('Madrid', 'Berlin','Bern')
      </code>

      <p>
        Фильтрация по нескольким условиям с применением AND (выполняются все условия)
        или OR (выполняется хотя бы одно условие) и нескольким значениям:
      </p>
      <code class="code">
        SELECT * FROM Customers
          WHERE Country = 'Germany' AND City NOT IN ('Berlin', 'Aachen') AND CustomerID > 15
      </code>
      </br>
      <code class="code">
        SELECT * FROM Customers
          WHERE City IN ('London', 'Berlin') OR CustomerID > 4
      </code>
      </br>

      <code>
        GROUP BY
      </code>
      <p>
        GROUP BY — необязательный элемент запроса, с помощью которого можно задать агрегацию по нужному столбцу
        (например, если нужно узнать какое количество клиентов живет в каждом из городов).
      </p>
      <p>
        При использовании GROUP BY обязательно:
      </p>

      <ol>
        <li>
          перечень столбцов, по которым делается разрез, был одинаковым внутри SELECT и внутри GROUP BY;
        </li>
        <li>
          агрегатные функции (SUM, AVG, COUNT, MAX, MIN) должны быть также указаны внутри SELECT с указанием столбца,
          к которому такая функция применяется.
        </li>
      </ol>

      <p>
        Группировка количества клиентов по городу:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) FROM Customers
          GROUP BY City
      </code>

      <p>
        Группировка количества клиентов по стране и городу:
      </p>
      <code class="code">
        SELECT Country, City, COUNT(CustomerID) FROM Customers
          GROUP BY Country, City
      </code>

      <p>
        Группировка продаж по ID товара с разными агрегатными функциями:
        количество заказов с данным товаром и количество проданных штук товара:
      </p>
      <code class="code">
        SELECT ProductID, COUNT(OrderID), SUM(Quantity) FROM OrderDetails
          GROUP BY ProductID
      </code>

      <p>
        Группировка продаж с фильтрацией исходной таблицы.
        В данном случае на выходе будет таблица с количеством клиентов по городам Германии:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) FROM Customers
          WHERE Country = 'Germany'
          GROUP BY City
      </code>

      <p>
        Переименование столбца с агрегацией с помощью оператора AS.
        По умолчанию название столбца с агрегацией равно примененной агрегатной функции,
        что далее может быть не очень удобно для восприятия.
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) AS Number_of_clients FROM Customers
          GROUP BY City
      </code>
      </br>

      <code>
        HAVING
      </code>
      <p>
        HAVING — необязательный элемент запроса, который отвечает за фильтрацию на уровне сгруппированных данных
        (по сути, WHERE, но только на уровень выше).
      </p>
      <p>
        Ключевое слово HAVING было добавлено в SQL по той причине, что WHERE не может использоваться для работы с агрегатными функциями.
      </p>

      <p>
        Фильтрация агрегированной таблицы с количеством клиентов по городам,
        в данном случае оставляем в выгрузке только те города, в которых не менее 5 клиентов:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) FROM Customers
          GROUP BY City
          HAVING COUNT(CustomerID) >= 5
      </code>

      <p>
        В случае с переименованным столбцом внутри HAVING можно указать как и саму агрегирующую конструкцию
        count(CustomerID), так и новое название столбца number_of_clients:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) AS number_of_clients FROM Customers
          GROUP BY City
          HAVING number_of_clients >= 5
      </code>

      <p>
        Пример запроса, содержащего WHERE и HAVING.
        В данном запросе сначала фильтруется исходная таблица по пользователям,
        рассчитывается количество клиентов по городам и остаются только те города, где количество клиентов не менее 5:
      </p>
      <code class="code">
        SELECT City, COUNT(CustomerID) AS number_of_clients FROM Customers
          WHERE CustomerName NOT IN ('Around the Horn','Drachenblut Delikatessend')
          GROUP BY City
          HAVING number_of_clients >= 5
      </code>
      </br>

      <code>
        ORDER BY
      </code>
      <p>
        ORDER BY используется для сортировки результатов запроса по убыванию или возрастанию.
        ORDER BY отсортирует по возрастанию, если не будет указан способ сортировки ASC или DESC.
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          ORDER BY &lt;col_name1>, &lt;col_name2>, … ASC|DESC;
      </code>

      <p>
        Простой пример сортировки по одному столбцу. В данном запросе осуществляется сортировка по городу, который указал клиент:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY City
      </code>

      <p>
        Осуществлять сортировку можно и по нескольким столбцам, в этом случае сортировка происходит по порядку указанных столбцов:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY Country, City
      </code>

      <p>
        По умолчанию сортировка происходит по возрастанию для чисел и в алфавитном порядке для текстовых значений.
        Если нужна обратная сортировка, то в конструкции ORDER BY после названия столбца надо добавить DESC:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY CustomerID DESC
      </code>

      <p>
        Обратная сортировка по одному столбцу и сортировка по умолчанию по второму:
      </p>
      <code class="code">
        SELECT * FROM Customers
          ORDER BY Country DESC, City
      </code>
      </br>

      <code>
        BETWEEN
      </code>
      <p>
        BETWEEN используется для выбора значений данных из определённого промежутка.
        Могут быть использованы числовые и текстовые значения, а также даты.
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;col_namex> BETWEEN &lt;value1> AND &lt;value2>;
      </code>
      </br>

      <code>
        LIKE
      </code>
      <p>
        Оператор LIKE используется в WHERE, чтобы задать шаблон поиска похожего значения.
      </p>
      <p>
        Есть два свободных оператора, которые используются в LIKE:
      </p>

      <ul>
        <li>% (ни одного, один или несколько символов);</li>
        <li>_ (один символ).</li>
      </ul>

      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;col_namex> LIKE &lt;pattern>;
      </code>
      </br>

      <code>
        IN
      </code>
      <p>
        С помощью IN можно указать несколько значений для оператора WHERE:
      </p>
      <code class="code">
        SELECT &lt;col_name1>, &lt;col_name2>, …
          FROM &lt;table_name>
          WHERE &lt;col_namen> IN (&lt;value1>, &lt;value2>, …);
      </code>
      </br>

      <code>
        JOIN
      </code>
      <p>
        JOIN — необязательный элемент, используется для объединения таблиц (двух и более) по ключу, который присутствует в обеих таблицах.
        Перед ключом ставится оператор ON.
      </p>

      <p>
        Запрос, в котором соединяем таблицы Order и Customer по ключу CustomerID,
        при этом перед названиям столбца ключа добавляется название таблицы через точку:
      </p>
      <code class="code">
        SELECT * FROM Orders
          JOIN Customers ON Orders.CustomerID = Customers.CustomerID
      </code>

      <p>
        Нередко может возникать ситуация, когда надо промэппить одну таблицу значениями из другой.
        В зависимости от задачи, могут использоваться разные типы присоединений.
        INNER JOIN — пересечение, RIGHT/LEFT JOIN для мэппинга одной таблицы знаениями из другой.
      </p>

      <p>
        Внутри всего запроса JOIN встраивается после элемента FROM до элемента WHERE, пример запроса:
      </p>
      <code class="code">
        SELECT * FROM Orders
          JOIN Customers ON Orders.CustomerID = Customers.CustomerID
          WHERE Customers.CustomerID >10
      </code>

      <p>
        Другие типы JOIN'ов можно увидеть на замечательной картинке ниже:
      </p>
      <img src="../assets/img/join.png">

      <p>
        Более подробно про JOIN можно прочитать в прикрепленном материале (см. Источник 2).
      </p>

      <code>
        VIEW
      </code>
      <p>
        VIEW — это виртуальная таблица SQL, созданная в результате выполнения выражения.
        Она содержит строки и столбцы и очень похожа на обычную SQL-таблицу. VIEW всегда показывает самую свежую информацию из базы данных.
      </p>

      <h3>
        Источники:
      </h3>

      <ul>
        <li>
          <a href="https://habr.com/ru/post/480838/">Источник 1 (основоной)</a>
        </li>
        <li>
          <a href="https://function-x.ru/sql_join.html">Источник 2 (про JOIN и его разновидности)</a>
        </li>
        <li>
          <a href="https://tproger.ru/translations/sql-recap/">Источник 3 (очень краткий конспект с перечнем функций)</a>
        </li>
      </ul>
    `,
    tags: ['СУБД (системы управления базами данных)', 'databases', 'SQL'],
    structure: [
      {
        name: 'SELECT, FROM',
        isChecked: false,
      },
      {
        name: 'SELECT DISTINCT',
        isChecked: false,
      },
      {
        name: 'WHERE',
        isChecked: false,
      },
      {
        name: 'GROUP BY',
        isChecked: false,
      },
      {
        name: 'HAVING',
        isChecked: false,
      },
      {
        name: 'ORDER BY',
        isChecked: false,
      },
      {
        name: 'JOIN и его варианты',
        isChecked: false,
      }
    ],
  },
  {
    id: 84,
    name: 'Формат JSON, метод toJSON',
    answer: `
      <h3>
        JSON.stringify
      </h3>

      <p>
        <span class="accent">JSON</span> (JavaScript Object Notation) – это общий формат для представления значений и объектов.
        Его описание задокументировано в стандарте RFC 4627 (ещё 2006 год). Первоначально он был создан для JavaScript,
        но многие другие языки также имеют библиотеки, которые могут работать с ним. Таким образом,
        JSON легко использовать для обмена данными, когда клиент использует JavaScript, а сервер написан на Ruby/PHP/Java
        или любом другом языке.
      </p>

      <p>JavaScript предоставляет методы:</p>
      <ul>
        <li><code>JSON.stringify</code> - для преобразования объектов в JSON.</li>
        <li><code>JSON.parse</code> - для преобразования JSON обратно в объект.</li>
      </ul>

      <p class="info info--blue">
        Полученная из метода <code>JSON.stringify</code> строка называется JSON-форматированным или
        <span class="accent">сериализованным объектом</span>.
        Мы можем отправить его по сети или поместить в обычное хранилище данных.
        </br>
        Соответственно, из метода <code>JSON.parse</code> - <span class="accent">десериализованным объектом</span>.
      </p>

      <p>Обратите внимание, что объект в формате JSON имеет несколько важных отличий от объектного литерала:</p>
      <ul>
        <li>
          Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON.
          Так <code>'John'</code> становится <code>"John"</code>.
        </li>
        <li>
          Имена свойств объекта также заключаются в двойные кавычки. Это обязательно.
          Так <code>age:30</code> становится <code>"age":30</code>.
        </li>
        <li>
          Не допускаются комментарии.
        </li>
      </ul>

      <p><code>JSON.stringify</code> может быть применён и к примитивам.</p>
      <p>JSON поддерживает следующие типы данных:</p>

      <ul>
        <li>Объекты <code>{ ... }</code></li>
        <li>Массивы <code>[ ... ]</code></li>
        <li>Примитивы:
        <ul>
          <li>строки,</li>
          <li>числа,</li>
          <li>логические значения <code>true/false</code>,</li>
          <li><code>null</code>.</li>
        </ul>
        </li>
      </ul>

      <code class="code">
        // число в JSON остаётся числом
        alert( JSON.stringify(1) ) // 1

        // строка в JSON по-прежнему остаётся строкой, но в двойных кавычках
        alert( JSON.stringify('test') ) // "test"

        alert( JSON.stringify(true) ); // true

        alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
      </code>

      <p>
        Самое замечательное, что вложенные объекты поддерживаются и конвертируются автоматически.
      </p>

      <p>
        JSON является независимой от языка спецификацией для данных, поэтому <code>JSON.stringify</code>
        пропускает некоторые специфические свойства объектов JavaScript.
      </p>
      <p>А именно:</p>

      <ul>
        <li>Свойства-функции (методы).</li>
        <li>Символьные свойства.</li>
        <li>Свойства, содержащие <code>undefined</code>.</li>
      </ul>

      <code class="code">
        let user = {
          sayHi() { // будет пропущено
            alert("Hello");
          },
          [Symbol("id")]: 123, // также будет пропущено
          something: undefined // как и это - пропущено
        };

        alert( JSON.stringify(user) ); // {} (пустой объект)
      </code>

      <p class="info info--blue">
        Важное ограничение: не должно быть циклических ссылок.
      </p>

      <code class="code">
        let room = {
          number: 23
        };

        let meetup = {
          title: "Conference",
          participants: ["john", "ann"]
        };

        meetup.place = room;       // meetup ссылается на room
        room.occupiedBy = meetup; // room ссылается на meetup

        JSON.stringify(meetup); // Ошибка: Преобразование цикличной структуры в JSON
      </code>

      <p>
        Здесь преобразование завершается неудачно из-за циклической ссылки:
        room.occupiedBy ссылается на meetup, и meetup.place ссылается на room.
      </p>

      <h3>
        Исключаем и преобразуем: replacer
      </h3>

      <p>
        Полный синтаксис <code>JSON.stringify</code>:
      </p>
      <code class="code">
        let json = JSON.stringify(value[, replacer, space]);
      </code>
      <ul>
        <li><strong>value</strong> - значение для кодирования</li>
        <li>
          <strong>replacer</strong> - массив свойств <code>([key, key...])</code> для кодирования
          или функция соответствия <code>function(key, value)</code>
        </li>
        <li><strong>space</strong> - Дополнительное пространство (отступы), используемое для форматирования</li>
      </ul>

      <p>
        В большинстве случаев <code>JSON.stringify</code> используется только с первым аргументом.
        Но если нам нужно настроить процесс замены, например, отфильтровать циклические ссылки,
        то можно использовать второй аргумент <code>JSON.stringify</code>.
        </br>
        Если мы передадим ему массив свойств, будут закодированы только эти свойства.
      </p>

      <code class="code">
        let room = {
          number: 23
        };

        let meetup = {
          title: "Conference",
          participants: [{name: "John"}, {name: "Alice"}],
          place: room // meetup ссылается на room
        };

        room.occupiedBy = meetup; // room ссылается на meetup

        alert( JSON.stringify(meetup, ['title', 'participants']) );
        // {"title":"Conference","participants":[{},{}]}
      </code>
      <p>
        Здесь мы, наверное, слишком строги. Список свойств применяется ко всей структуре объекта.
        Так что внутри participants – пустые объекты, потому что name нет в списке.
      </p>

      <p>
        Если мы хотим, чтобы больше свойств было сериализовано, но не хотим указывать все имена свойств через запятую,
        можем использовать функцию-replacer.
        </br>
        В качестве replacer мы можем использовать функцию, а не массив.
        Функция будет вызываться для каждой пары (key, value), и она должна возвращать заменённое значение,
        которое будет использоваться вместо исходного. Или undefined, чтобы пропустить значение.
        (для более подробной информации см. Источник)
      </p>
      <code class="code">
        JSON.stringify(myObject, function replacer(key, value) {
          return (key == 'keyNameToSkip') ? undefined : value;
        })
      </code>

      <h3>
        Форматирование: space
      </h3>
      <p>
        Третий аргумент в <code>JSON.stringify(value, replacer, space)</code> - это количество пробелов,
        используемых для удобного форматирования.
      </p>

      <p>
        Ранее все JSON-форматированные объекты не имели отступов и лишних пробелов.
        Это нормально, если мы хотим отправить объект по сети. Аргумент <code>space</code>
        используется исключительно для вывода в удобочитаемом виде.
      </p>

      <h3>
        Пользовательский «toJSON»
      </h3>
      <p>
        Как и <code>toString</code> для преобразования строк, объект может предоставлять метод <code>toJSON</code>
        для преобразования в JSON. <code>JSON.stringify</code> автоматически вызывает его, если он есть.
      </p>

      <p>
        Например, добавим собственную реализацию метода <code>toJSON</code> в наш объект room:
      </p>
      <code class="code">
        let room = {
          number: 23,
          toJSON() {
            return this.number;
          }
        };

        let meetup = {
          title: "Conference",
          room
        };

        alert( JSON.stringify(room) ); // 23

        alert( JSON.stringify(meetup) );
        /*
          {
            "title":"Conference",
            "room": 23
          }
        */
      </code>
      <p>
        Как видите, <code>toJSON</code> используется как при прямом вызове <code>JSON.stringify(room)</code>,
        так и когда room вложен в другой сериализуемый объект.
      </p>

      <h3>
        JSON.parse
      </h3>

      <p>
        Чтобы декодировать JSON-строку, нам нужен другой метод с именем <code>JSON.parse</code>.
      </p>
      <code class="code">
        let value = JSON.parse(str, [reviver]);
      </code>
      <ul>
        <li><strong>str</strong> - JSON для преобразования в объект</li>
        <li>
          <strong>reviver</strong> - необязательная функция, которая будет вызываться для каждой пары
          (ключ, значение) и может преобразовывать значение
        </li>
      </ul>

      <h3>
        Использование reviver
      </h3>

      <p>
        Представьте, что мы получили объект meetup с сервера в виде строки данных.
      </p>
      <code class="code">
        // title: (meetup title), date: (meetup date)
        let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
      </code>

      <p>
        А теперь десериализуем её, т.е. снова превратим в объект JavaScript и попробуем обратиться к объекту Date.
      </p>
      <code class="code">
        let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
        let meetup = JSON.parse(str);

        alert( meetup.date.getDate() ); // Error!
      </code>
      <p>
        Ой, ошибка!

        Значением meetup.date является строка, а не Date объект. Как <code>JSON.parse</code> мог знать,
        что он должен был преобразовать эту строку в Date?
      </p>

      <p>
        Давайте передадим <code>JSON.parse</code> функцию восстановления вторым аргументом,
        которая возвращает все значения «как есть», но date станет Date:
      </p>
      <code class="code">
        let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

        let meetup = JSON.parse(str, function(key, value) {
          if (key == 'date') return new Date(value);
          return value;
        });

        alert( meetup.date.getDate() ); // 30 - теперь работает!
      </code>
      <p>
        Кстати, это работает и для вложенных объектов, в которых бедет ключ date!
      </p>

      <h3>
        Источники:
      </h3>
      <ul>
        <li>
          <a href="https://learn.javascript.ru/json">Источник 1</a>
        </li>
      </ul>
    `,
    tags: ['JSON', 'Data Structures'],
    structure: [
      {
        name: 'Теги HTML',
        isChecked: false,
      }
    ],
  },
];
